#!/usr/bin/env node
'use strict';

/** Load Node.js modules */
var vm = require('vm');

/** Load other modules */
var _ = require('lodash/lodash.js'),
    minify = require('../lib/minify.js'),
    util = require('../lib/util.js');

/** Module shortcuts */
var fs = util.fs,
    path = util.path;

/** The current working directory */
var cwd = process.cwd();

/** Native method shortcuts */
var push = Array.prototype.push;

/** Used to create regexes that may detect multi-line comment blocks */
var multilineComment = '(?: */\\*[^*]*\\*+(?:[^/][^*]*\\*+)*/\\n)?';

/** Used to replace string literals with tokens */
var stringToken = '__lodash@' + _.VERSION + '__token__';

/** Used to detect the JSDoc `@type` tag of "Function" */
var reFuncTag = /^ *\* *@type +Function\b/im;

/** Used to detect if a string is a function snippet */
var reFuncSnippet = /\b(?:function(?:\s+[$\w]+)?|create[A-Z][a-z]+|template)\(/;

/** Used to detect the Node.js executable in command-line arguments */
var reNode = RegExp('(?:^|' + path.sepEscaped + ')node(?:\\.exe)?$', 'i');

/** Used to match string literals */
var reStrings = /(["'])(?:(?!\1)[^\n\\]|\\.)*\1/g;

/** Used to match string tokens */
var reStringTokens = RegExp(stringToken.replace(/\./g, '\\$&'), 'g');

/** Shortcut to the `stdout` object */
var stdout = process.stdout;

/** Used to associate aliases with their real names */
var aliasToRealMap = createMap({
  'all': 'every',
  'any': 'some',
  'collect': 'map',
  'callback': 'createCallback',
  'detect': 'find',
  'each': 'forEach',
  'eachRight': 'forEachRight',
  'extend': 'assign',
  'foldl': 'reduce',
  'foldr': 'reduceRight',
  'head': 'first',
  'include': 'contains',
  'inject': 'reduce',
  'methods': 'functions',
  'object': 'zipObject',
  'select': 'filter',
  'tail': 'rest',
  'toJSON': 'wrapperValueOf',
  'unique': 'uniq',
  'unzip': 'zip',
  'value': 'wrapperValueOf'
});

/** Used to associate real names with their aliases */
var realToAliasMap = createMap({
  'assign': ['extend'],
  'contains': ['include'],
  'createCallback': ['callback'],
  'every': ['all'],
  'filter': ['select'],
  'find': ['detect'],
  'first': ['head'],
  'forEach': ['each'],
  'forEachRight': ['eachRight'],
  'functions': ['methods'],
  'map': ['collect'],
  'reduce': ['foldl', 'inject'],
  'reduceRight': ['foldr'],
  'rest': ['tail'],
  'some': ['any'],
  'uniq': ['unique'],
  'wrapperValueOf': ['toJSON', 'value'],
  'zip': ['unzip'],
  'zipObject': ['object']
});

/** Used to track function dependencies */
var funcDependencyMap = createMap({
  // properties
  'support': ['isNative'],
  'templateSettings': ['escape'],

  // public functions
  'after': ['isFunction'],
  'assign': ['baseCreateCallback', 'keys'],
  'at': ['baseAt', 'baseFlatten', 'isString'],
  'bind': ['createWrapper', 'slice'],
  'bindAll': ['baseFlatten', 'createWrapper', 'functions'],
  'bindKey': ['createWrapper', 'slice'],
  'camelCase': ['createCompounder'],
  'capitalize': [],
  'chain': ['lodashWrapper'],
  'clone': ['baseClone', 'baseCreateCallback'],
  'cloneDeep': ['baseClone', 'baseCreateCallback'],
  'compact': [],
  'compose': ['isFunction'],
  'constant': [],
  'contains': ['getIndexOf', 'isArray', 'isNative', 'isString', 'values'],
  'countBy': ['createAggregator'],
  'create': ['assign', 'baseCreate'],
  'createCallback': ['baseCreateCallback', 'matches', 'property'],
  'curry': ['createWrapper'],
  'debounce': ['isFunction', 'isObject', 'now'],
  'defaults': ['assign', 'assignDefaults', 'slice'],
  'defer': ['isFunction', 'slice'],
  'delay': ['isFunction', 'slice'],
  'difference': ['baseDifference', 'baseFlatten', 'isArguments', 'isArray'],
  'drop': ['rest'],
  'dropRight': ['initial'],
  'dropRightWhile': ['initial'],
  'dropWhile': ['rest'],
  'endsWith': [],
  'escape': ['escapeHtmlChar'],
  'escapeRegExp': [],
  'every': ['baseEach', 'createCallback', 'isArray'],
  'filter': ['baseEach', 'createCallback', 'isArray'],
  'find': ['baseEach', 'baseFind', 'createCallback', 'findIndex', 'isArray'],
  'findIndex': ['createCallback'],
  'findLastIndex': ['createCallback'],
  'findKey': ['baseFind', 'baseForOwn', 'createCallback'],
  'findLast': ['baseEachRight', 'baseFind', 'createCallback'],
  'findLastKey': ['baseFind', 'baseForOwnRight', 'createCallback'],
  'findWhere': ['find', 'matches'],
  'first': ['createCallback', 'slice'],
  'flatten': ['baseFlatten', 'map'],
  'forEach': ['arrayEach', 'baseCreateCallback', 'baseEach', 'isArray'],
  'forEachRight': ['arrayEachRight', 'baseCreateCallback', 'baseEachRight', 'isArray'],
  'forIn': ['baseCreateCallback', 'baseFor', 'keysIn'],
  'forInRight': ['baseCreateCallback', 'baseForRight', 'keysIn'],
  'forOwn': ['baseForOwn', 'baseCreateCallback'],
  'forOwnRight': ['baseCreateCallback', 'baseForRight', 'keys'],
  'functions': ['baseForIn', 'isFunction'],
  'groupBy': ['createAggregator'],
  'has': [],
  'identity': [],
  'indexBy': ['createAggregator'],
  'indexOf': ['baseIndexOf', 'sortedIndex'],
  'initial': ['createCallback', 'slice'],
  'intersection': ['cacheIndexOf', 'createCache', 'getIndexOf', 'isArguments', 'isArray'],
  'invert': ['keys'],
  'invoke': ['baseEach', 'slice'],
  'isArguments': [],
  'isArray': ['isNative'],
  'isBoolean': [],
  'isDate': [],
  'isElement': ['isNode', 'isPlainObject'],
  'isEmpty': ['baseForOwn', 'isArguments', 'isArray', 'isFunction', 'isString'],
  'isEqual': ['baseCreateCallback', 'baseIsEqual'],
  'isError': [],
  'isFinite': [],
  'isFunction': [],
  'isNaN': ['isNumber'],
  'isNull': [],
  'isNumber': [],
  'isObject': [],
  'isPlainObject': ['isArguments', 'isNative', 'shimIsPlainObject'],
  'isRegExp': ['isObject'],
  'isString': [],
  'isUndefined': [],
  'kebabCase': ['createCompounder'],
  'keys': ['isNative', 'isObject', 'shimKeys'],
  'keysIn': ['isArguments', 'isArray', 'isObject', 'isString'],
  'last': ['createCallback', 'slice'],
  'lastIndexOf': [],
  'lodash': ['isArray', 'lodashWrapper'],
  'map': ['arrayMap', 'baseEach', 'createCallback', 'isArray'],
  'mapValues': ['baseForOwn', 'createCallback'],
  'matches': ['baseIsEqual', 'isObject', 'keys'],
  'max': ['baseEach', 'charAtCallback', 'createCallback', 'isArray', 'isString'],
  'memoize': ['isFunction'],
  'merge': ['baseCreateCallback', 'baseMerge', 'slice'],
  'min': ['baseEach', 'charAtCallback', 'createCallback', 'isArray', 'isString'],
  'mixin': ['functions', 'isFunction', 'isObject', 'lodash'],
  'negate': ['isFunction'],
  'noConflict': [],
  'noop': [],
  'now': ['isNative'],
  'omit': ['baseDifference', 'baseFlatten', 'createCallback', 'keysIn', 'negate', 'pick'],
  'once': ['isFunction'],
  'pad': ['createPad'],
  'padLeft': ['createPad'],
  'padRight': ['createPad'],
  'pairs': ['keys'],
  'parseInt': ['trim'],
  'partial': ['createWrapper', 'slice'],
  'partialRight': ['createWrapper', 'slice'],
  'partition': ['createAggregator'],
  'pick': ['baseFlatten', 'baseForIn', 'createCallback', 'isObject'],
  'pluck': ['map', 'property'],
  'property': [],
  'pull': [],
  'pullAt': ['baseAt', 'baseCompareAscending', 'baseFlatten'],
  'random': ['baseRandom'],
  'range': [],
  'reduce': ['baseEach', 'createCallback', 'isArray'],
  'reduceRight': ['createCallback', 'baseEachRight'],
  'reject': ['createCallback', 'filter', 'negate'],
  'remove': ['createCallback'],
  'repeat': [],
  'rest': ['createCallback', 'slice'],
  'result': ['isFunction'],
  'runInContext': ['defaults', 'pick'],
  'sample': ['baseRandom', 'isString', 'shuffle', 'values'],
  'shuffle': ['baseEach', 'baseRandom'],
  'size': ['keys'],
  'slice': [],
  'snakeCase': ['createCompounder'],
  'startsWith': [],
  'some': ['baseEach', 'createCallback', 'isArray'],
  'sortBy': ['baseEach', 'compareAscending', 'compareMultipleAscending', 'createCallback', 'isArray'],
  'sortedIndex': ['createCallback', 'identity'],
  'take': ['first'],
  'takeRight': ['last'],
  'takeRightWhile': ['last'],
  'takeWhile': ['first'],
  'tap': [],
  'template': ['defaults', 'escape', 'escapeStringChar', 'keys', 'values'],
  'throttle': ['debounce', 'isFunction', 'isObject'],
  'times': ['baseCreateCallback'],
  'toArray': ['isString', 'slice', 'values'],
  'transform': ['arrayEach', 'baseCreate', 'baseForOwn', 'createCallback', 'isArray', 'isObject'],
  'trim': ['charsLeftIndex', 'charsRightIndex', 'trimmedLeftIndex', 'trimmedRightIndex'],
  'trimLeft': ['charsLeftIndex', 'trimmedLeftIndex'],
  'trimRight': ['charsRightIndex', 'trimmedRightIndex'],
  'truncate': ['isObject', 'isRegExp'],
  'unescape': ['unescapeHtmlChar'],
  'union': ['baseFlatten', 'baseUniq'],
  'uniq': ['baseUniq', 'createCallback'],
  'uniqueId': [],
  'values': ['baseValues', 'keys'],
  'valuesIn': ['baseValues', 'keysIn'],
  'where': ['filter', 'matches'],
  'without': ['baseDifference', 'slice'],
  'wrap': ['createWrapper'],
  'wrapperChain': [],
  'wrapperToString': [],
  'wrapperValueOf': [],
  'xor': ['baseDifference', 'baseUniq', 'isArguments', 'isArray'],
  'zip': ['max', 'pluck'],
  'zipObject': ['isArray'],

  // private functions
  'arrayEach': [],
  'arrayEachRight': [],
  'arrayMap': [],
  'assignDefaults': [],
  'baseAt': [],
  'baseBind': ['baseCreate', 'composeArgs', 'isObject', 'setData'],
  'baseClone': ['arrayEach', 'assign', 'baseForOwn', 'isArray', 'isObject', 'isNode', 'slice'],
  'baseCompareAscending': [],
  'baseCreate': ['isNative', 'isObject'],
  'baseCreateCallback': ['bind', 'identity', 'setData'],
  'baseCreateWrapper': ['baseCreate', 'composeArgs', 'composeArgsRight', 'isObject', 'setData'],
  'baseDifference': ['cacheIndexOf', 'createCache', 'getIndexOf'],
  'baseEach': ['baseForOwn', 'isString'],
  'baseEachRight': ['baseForOwnRight', 'isString'],
  'baseFind': [],
  'baseFlatten': ['isArguments', 'isArray'],
  'baseFor': [],
  'baseForIn': ['baseFor', 'keysIn'],
  'baseForOwn': ['baseFor', 'keys'],
  'baseForOwnRight': ['baseForRight', 'keys'],
  'baseForRight': [],
  'baseIndexOf': [],
  'baseIsEqual': ['baseForIn', 'isArguments', 'isFunction', 'isNode'],
  'baseMerge': ['arrayEach', 'baseForOwn', 'isArray', 'isPlainObject'],
  'baseRandom': [],
  'baseUniq': ['cacheIndexOf', 'createCache', 'getIndexOf'],
  'baseValues': [],
  'cacheIndexOf': [],
  'charAtCallback': [],
  'charsLeftIndex': [],
  'charsRightIndex': [],
  'compareAscending': ['baseCompareAscending'],
  'compareMultipleAscending': ['baseCompareAscending'],
  'composeArgs': [],
  'composeArgsRight': [],
  'createAggregator': ['baseEach', 'createCallback', 'isArray'],
  'createWrapper': ['baseBind', 'baseCreateWrapper', 'getHolders', 'isFunction', 'slice'],
  'createCache': ['isNative'],
  'createCompounder': ['deburrLetter'],
  'createPad': ['repeat'],
  'deburrLetter': [],
  'escapeHtmlChar': [],
  'escapeStringChar': [],
  'getHolders': ['lodash'],
  'getIndexOf': ['baseIndexOf', 'indexOf'],
  'isNative': ['escapeRegExp'],
  'isNode': [],
  'lodashWrapper': [],
  'setData': ['isNative', 'noop'],
  'shimIsPlainObject': ['baseForIn', 'isArguments', 'isFunction', 'isNode'],
  'shimKeys': ['isArguments', 'isArray', 'isString', 'keysIn'],
  'trimmedLeftIndex': [],
  'trimmedRightIndex': [],
  'unescapeHtmlChar': []
});

/** Used to track Lo-Dash object dependencies of identifiers */
var objDependencyMap = createMap({
  'at': ['support'],
  'baseClone': ['support'],
  'baseCreateCallback': ['support'],
  'baseEach': ['support'],
  'baseEachRight': ['support'],
  'baseIsEqual': ['support'],
  'isArguments': ['support'],
  'isElement': ['support'],
  'isPlainObject': ['support'],
  'keysIn': ['support'],
  'sample': ['support'],
  'shimIsPlainObject': ['support'],
  'shimKeys': ['support'],
  'template': ['templateSettings'],
  'toArray': ['support']
});

/** Used to track variable dependencies of identifiers */
var varDependencyMap = createMap({
  'after': ['root'],
  'baseCreate': ['root'],
  'createCache': ['root'],
  'createPad': ['root'],
  'isFinite': ['root'],
  'pad': ['root'],
  'parseInt': ['root'],
  'repeat': ['root'],
  'support': ['root'],
  'template': ['reInterpolate'],
  'templateSettings': ['reEscape', 'reEvaluate', 'reInterpolate']
});

/** Used to track the category of identifiers */
var categoryMap = createMap({
  'Arrays': [
    'compact',
    'difference',
    'drop',
    'dropRight',
    'dropRightWhile',
    'dropWhile',
    'findIndex',
    'findLastIndex',
    'first',
    'flatten',
    'indexOf',
    'initial',
    'intersection',
    'last',
    'lastIndexOf',
    'pull',
    'pullAt',
    'remove',
    'rest',
    'slice',
    'sortedIndex',
    'take',
    'takeRight',
    'takeRightWhile',
    'takeWhile',
    'union',
    'uniq',
    'without',
    'xor',
    'zip',
    'zipObject',

    // deprecated
    'range'
  ],
  'Chaining': [
    'chain',
    'lodash',
    'tap',
    'wrapperChain',
    'wrapperToString',
    'wrapperValueOf'
  ],
  'Collections': [
    'at',
    'contains',
    'countBy',
    'every',
    'filter',
    'find',
    'findLast',
    'findWhere',
    'forEach',
    'forEachRight',
    'groupBy',
    'indexBy',
    'invoke',
    'map',
    'max',
    'min',
    'partition',
    'pluck',
    'reduce',
    'reduceRight',
    'reject',
    'sample',
    'shuffle',
    'size',
    'some',
    'sortBy',
    'toArray',
    'where'
  ],
  'Functions': [
    'after',
    'bind',
    'bindAll',
    'bindKey',
    'compose',
    'curry',
    'debounce',
    'defer',
    'delay',
    'memoize',
    'negate',
    'once',
    'partial',
    'partialRight',
    'throttle',
    'wrap',

    // deprecated
    'createCallback'
  ],
  'Objects': [
    'assign',
    'clone',
    'cloneDeep',
    'create',
    'defaults',
    'findKey',
    'findLastKey',
    'forIn',
    'forInRight',
    'forOwn',
    'forOwnRight',
    'functions',
    'has',
    'invert',
    'isArguments',
    'isArray',
    'isBoolean',
    'isDate',
    'isElement',
    'isEmpty',
    'isEqual',
    'isError',
    'isFinite',
    'isFunction',
    'isNaN',
    'isNull',
    'isNumber',
    'isObject',
    'isPlainObject',
    'isRegExp',
    'isString',
    'isUndefined',
    'keys',
    'keysIn',
    'mapValues',
    'merge',
    'omit',
    'pairs',
    'pick',
    'transform',
    'values',
    'valuesIn'
  ],
  'Strings': [
    'camelCase',
    'capitalize',
    'endsWith',
    'escapeRegExp',
    'kebabCase',
    'pad',
    'padLeft',
    'padRight',
    'repeat',
    'snakeCase',
    'startsWith',
    'trim',
    'trimLeft',
    'trimRight',
    'truncate'
  ],
  'Utilities': [
    'constant',
    'identity',
    'matches',
    'mixin',
    'noConflict',
    'noop',
    'now',
    'parseInt',
    'property',
    'random',
    'result',
    'runInContext',
    'times',
    'uniqueId',

    // deprecated
    'escape',
    'template',
    'templateSettings',
    'unescape',
  ]
});

/** Used to track identifiers that are changing categories in the next major version bump */
var categoryFluxMap = {
  'Strings': [
    'escape',
    'template',
    'templateSettings',
    'unescape'
  ],
  'Utilities': [
    'createCallback',
    'range'
  ]
};

/* Used to enforce dependencies at the top level */
var topLevel = createMap({
  'lodash': true,
  'support': true
});

/** List of Backbone's Lo-Dash dependencies */
var backboneDependencies = [
  'bind',
  'bindAll',
  'chain',
  'clone',
  'contains',
  'countBy',
  'defaults',
  'difference',
  'escape',
  'every',
  'extend',
  'filter',
  'find',
  'first',
  'forEach',
  'groupBy',
  'has',
  'indexBy',
  'indexOf',
  'initial',
  'invert',
  'invoke',
  'isArray',
  'isEmpty',
  'isEqual',
  'isFunction',
  'isObject',
  'isRegExp',
  'isString',
  'keys',
  'last',
  'lastIndexOf',
  'lodash',
  'map',
  'max',
  'min',
  'mixin',
  'omit',
  'once',
  'pairs',
  'pick',
  'reduce',
  'reduceRight',
  'reject',
  'rest',
  'result',
  'sample',
  'shuffle',
  'size',
  'some',
  'sortBy',
  'sortedIndex',
  'toArray',
  'uniqueId',
  'value',
  'values',
  'without',
  'wrapperChain',
  'wrapperValueOf'
];

/** List of all function categories */
var allCategories = _.keys(categoryMap);

/** List of the default ways to export the `lodash` function */
var defaultExports = [
  'amd',
  'commonjs',
  'global',
  'node'
];

/** List of variables with complex assignments */
var complexVars = [
  'cloneableClasses',
  'contextProps',
  'ctorByClass',
  'defineProperty',
  'freeGlobal',
  'nonEnumProps',
  'shadowedProps',
  'support',
  'whitespace'
];

/** List of functions to deep inline */
var inlineableFuncs = [
  'after',
  'arrayEach',
  'arrayEachRight',
  'arrayMap',
  'assignDefaults',
  'baseAt',
  'baseCompareAscending',
  'baseCreate',
  'baseRandom',
  'cacheIndexOf',
  'capitalize',
  'charAtCallback',
  'charsLeftIndex',
  'charsRightIndex',
  'compareAscending',
  'compareMultipleAscending',
  'compose',
  'composeArgs',
  'composeArgsRight',
  'constant',
  'createCache',
  'createCompounder',
  'createPad',
  'deburrLetter',
  'defer',
  'delay',
  'escape',
  'escapeHtmlChar',
  'escapeRegExp',
  'escapeStringChar',
  'getHolders',
  'has',
  'identity',
  'isArguments',
  'isArray',
  'isBoolean',
  'isDate',
  'isElement',
  'isError',
  'isFinite',
  'isFunction',
  'isNative',
  'isNaN',
  'isNode',
  'isNull',
  'isNumber',
  'isObject',
  'isRegExp',
  'isString',
  'isUndefined',
  'memoize',
  'negate',
  'noop',
  'now',
  'once',
  'parseInt',
  'result',
  'setData',
  'slice',
  'trimmedLeftIndex',
  'trimmedRightIndex',
  'unescape',
  'unescapeHtmlChar',
  'uniqueId'
];

/** List of Lo-Dash only functions */
var lodashOnlyFuncs = [
  'at',
  'bindKey',
  'capitalize',
  'camelCase',
  'cloneDeep',
  'create',
  'createCallback',
  'curry',
  'dropRight',
  'dropRightWhile',
  'dropWhile',
  'endsWith',
  'escapeRegExp',
  'findIndex',
  'findKey',
  'findLast',
  'findLastIndex',
  'findLastKey',
  'forEachRight',
  'forIn',
  'forInRight',
  'forOwn',
  'forOwnRight',
  'isError',
  'isPlainObject',
  'kebabCase',
  'keysIn',
  'mapValues',
  'merge',
  'negate',
  'noop',
  'pad',
  'padLeft',
  'padRight',
  'parseInt',
  'partialRight',
  'pull',
  'pullAt',
  'remove',
  'repeat',
  'runInContext',
  'slice',
  'snakeCase',
  'startsWith',
  'takeRight',
  'takeRightWhile',
  'takeWhile',
  'transform',
  'truncate',
  'trim',
  'trimLeft',
  'trimRight',
  'valuesIn',
  'wrapperToString',
  'xor'
];

/** List of private functions */
var privateFuncs = [
  'arrayEach',
  'arrayEachRight',
  'arrayMap',
  'assignDefaults',
  'baseAt',
  'baseBind',
  'baseClone',
  'baseCompareAscending',
  'baseCreate',
  'baseCreateCallback',
  'baseCreateWrapper',
  'baseDifference',
  'baseEach',
  'baseFind',
  'baseFlatten',
  'baseFor',
  'baseForIn',
  'baseForOwn',
  'baseForOwnRight',
  'baseForRight',
  'baseIndexOf',
  'baseIsEqual',
  'baseMerge',
  'baseRandom',
  'baseUniq',
  'baseValues',
  'cacheIndexOf',
  'charAtCallback',
  'charsLeftIndex',
  'charsRightIndex',
  'compareAscending',
  'compareMultipleAscending',
  'composeArgs',
  'composeArgsRight',
  'createAggregator',
  'createWrapper',
  'createCache',
  'createCompounder',
  'createPad',
  'deburrLetter',
  'escapeHtmlChar',
  'escapeStringChar',
  'getHolders',
  'getIndexOf',
  'isNative',
  'isNode',
  'lodashWrapper',
  'setData',
  'shimIsPlainObject',
  'shimKeys',
  'trimmedLeftIndex',
  'trimmedRightIndex',
  'unescapeHtmlChar'
];

/** List of all property dependencies */
var objDependencies = _.uniq(_.transform(objDependencyMap, _.bind(push.apply, push), []));

/** List of all variable dependencies */
var varDependencies = _.uniq(_.transform(varDependencyMap, _.bind(push.apply, push), []));

/** List of all functions */
var allFuncs = _.filter(_.difference(_.keys(funcDependencyMap), objDependencies, varDependencies), function(key) {
  var type = typeof _[key];
  return type == 'function' || type == 'undefined';
});

/** List of Lo-Dash functions */
var lodashFuncs = _.difference(allFuncs, privateFuncs);

/** List of Underscore functions */
var underscoreFuncs = _.difference(allFuncs, lodashOnlyFuncs, privateFuncs);

/*----------------------------------------------------------------------------*/

/**
 * Adds build `commands` to the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {Array} [commands=[]] An array of commands.
 * @returns {string} Returns the modified source.
 */
function addCommandsToHeader(source, commands) {
  return source.replace(getHeader(source), function(header) {
    // remove `node path/to/build.js` from `commands`
    if (reNode.test(commands[0])) {
      commands.splice(0, 2);
    }
    // add quotes to commands with spaces or equals signs
    commands = _.map(commands, function(command) {
      var separator = command.match(/[= ]/);
      if (separator) {
        separator = separator[0];
        var pair = command.split(separator);
        command = pair[0] + separator + '"' + pair[1] + '"';
      }
      // escape newlines, carriage returns, multi-line comment end tokens
      command = command
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\*\//g, '*\\/');

      return command;
    });

    // add build commands to copyright/license header
    return header.replace(/(\/\**\n)( \*)( *@license[\s*]+)?( *Lo-Dash [.$\w\-]+)(.*)/, function() {
      return (
        arguments[1] +
        arguments[2] +
        (arguments[3] || '') +
        arguments[4] + ' (Custom Build)' + arguments[5] + '\n' +
        arguments[2] + ' Build: `lodash ' + commands.join(' ') + '`'
      );
    });
  });
}

/**
 * Adds support for Underscore style chaining to `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {boolean} [isModularize=false] A flag to specify a modularize build
 * @returns {string} Returns the modified source.
 */
function addUnderscoreChaining(source, isModularize) {
  // replace `_.mixin`
  source = replaceFunction(source, 'mixin', (isModularize
    ? [
        'function mixin(object, source) {',
        '  if (!source) {',
        '    source = object;',
        '    object = lodash;',
        '  }',
        '  var index = -1,',
        '      isFunc = isFunction(object),',
        '      methodNames = functions(source),',
        '      length = methodNames.length;',
        '',
        '  while (++index < length) {',
        '    var methodName = methodNames[index],',
        '        func = object[methodName] = source[methodName];',
        '',
        '    if (isFunc) {',
        '      object.prototype[methodName] = (function(func) {',
        '        return function() {',
        '          var args = [this.__wrapped__];',
        '          push.apply(args, arguments);',
        '',
        '          var result = func.apply(object, args);',
        '          if (this.__chain__) {',
        '            result = new object(result);',
        '            result.__chain__ = true;',
        '          }',
        '          return result;',
        '        };',
        '      }(func));',
        '    }',
        '  }',
        '}'
      ]
    : [
        'function mixin(source) {',
        '  var index = -1,',
        '      methodNames = functions(source),',
        '      length = methodNames.length;',
        '',
        '  while (++index < length) {',
        '    var methodName = methodNames[index];',
        '    lodash.prototype[methodName] = (function() {',
        '      var func = lodash[methodName] = source[methodName];',
        '      return function() {',
        '        var args = [this.__wrapped__];',
        '        push.apply(args, arguments);',
        '',
        '        var result = func.apply(lodash, args);',
        '        return this.__chain__',
        '          ? new lodashWrapper(result, true)',
        '          : result;',
        '      };',
        '    }());',
        '  }',
        '}'
      ]
  ).join('\n'));

  // move `mixin(...)` before `_.VERSION`
  source = source.replace(getMethodAssignments(source), function(match) {
    match = removeMixinCalls(match);
    return match.replace(/^(?: *\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/\n)?( *)lodash\.VERSION\b/m, function(match, indent) {
      return indent + [
        '// add functions to `lodash.prototype`',
        'mixin(assign({}, lodash));',
      ].join('\n' + indent) +
      '\n\n' + match
    });
  });

  // replace wrapper `Array` method assignments
  source = source.replace(/^(?:(?: *\/\/.*\n)*( *)(?:if *\([^{]+\{\n\1( *))?arrayEach\(\['[\s\S]+?\n\1\2}\);(?:\n\1})?\n+)+/m, function(match, indent) {
    return indent + [
      '// add `Array` mutator functions to the wrapper',
      "arrayEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {",
      '  var func = arrayRef[methodName];',
      '  lodash.prototype[methodName] = function() {',
      '    var value = this.__wrapped__;',
      '    func.apply(value, arguments);',
      '',
      '    // avoid array-like object bugs with `Array#shift` and `Array#splice`',
      '    // in Firefox < 10 and IE < 9',
      '    if (!support.spliceObjects && value.length === 0) {',
      '      delete value[0];',
      '    }',
      '    return this;',
      '  };',
      '});',
      '',
      '// add `Array` accessor functions to the wrapper',
      "arrayEach(['concat', 'join', 'slice'], function(methodName) {",
      '  var func = arrayRef[methodName];',
      '  lodash.prototype[methodName] = function() {',
      '    var value = this.__wrapped__,',
      '        result = func.apply(value, arguments);',
      '',
      '    if (this.__chain__) {',
      '      result = new lodashWrapper(result);',
      '      result.__chain__ = true;',
      '    }',
      '    return result;',
      '  };',
      '});',
      ''
    ].join('\n' + indent);
  });

  // remove `lodash.prototype` methods assignments for `toJSON`, `toString`, and `valueOf`
  source = source.replace(/^ *lodash\.prototype\.(?:toJSON|toString|valueOf) *=.+\n/gm, '');

  // remove `lodash.prototype` batch method assignments
  source = source.replace(/^(?: *\/\/.*\n)*( *)baseForOwn\(lodash,[\s\S]+?\n\1}.+\n/gm, '');

  return source;
}

/**
 * Creates modules based on the provided build state.
 *
 * @private
 * @param {Object} state The build state object.
 * @param {Function} [callback] The function called when all module builds are completed.
 */
function buildModule(state, callback) {
  var buildFuncs = state.buildFuncs,
      funcDepMap = state.funcDepMap,
      includeObjs = state.includeObjs,
      includeVars = state.includeVars,
      isAMD = state.isAMD,
      isCommonJS = state.isCommonJS,
      isES6 = state.isES6,
      isNode = state.isNode,
      isNpm = state.isNpm,
      isSilent = state.isSilent,
      isUnderscore = state.isUnderscore,
      objDepMap = state.objDepMap,
      outputPath = state.outputPath,
      varDepMap = state.varDepMap;

  var templatePath = fs.realpathSync(path.join(__dirname, '..', 'template')),
      licenseTemplate = fs.readFileSync(path.join(templatePath, 'license.jst'), 'utf-8'),
      packageTemplate = fs.readFileSync(path.join(templatePath, 'package.jst'), 'utf-8'),
      readmeTemplate = fs.readFileSync(path.join(templatePath, 'readme.jst'), 'utf-8');

  var empty = [],
      identifiers = buildFuncs.concat(includeObjs, includeVars),
      removedDeps = {},
      version = state.lodash.VERSION;

  var buildCallback = function(data) {
    var source = data.source;
    source = addCommandsToHeader(source, state.options);
    data.source = cleanupSource(source);
    defaultBuildCallback(data);
  };

  var getInlinees = function(identifier, result) {
    var privateDeps = _.filter(funcDepMap[identifier], isPrivate);
    result || (result = []);

    _.each(privateDeps, function(funcName) {
      var dependants = getDependants(funcName, funcDepMap, true);

      // only inline functions if they have one dependent or all dependants are inlined
      if (!(_.size(dependants) == 1 || _.isEmpty(_.difference(dependants, result)))) {
        return;
      }
      result.push(funcName);

      // inline object and variable dependencies if all dependants are inlined
      _.each([objDepMap, varDepMap], function(depMap, index) {
        _.each(depMap[funcName], function(depName) {
          var dependants = getDependants(depName, depMap, true);
          if (_.isEmpty(_.difference(dependants, result))) {
            result.push(depName);
          }
        });
      });

      getInlinees(funcName, result);
    });

    return result;
  };

  var getUnusedDeps = function(source, depNames) {
    source = cleanupSource(removeStrings(removeComments(source)));
    return _.reject(depNames, function(depName) {
      return RegExp('\\b' + depName + '\\b').test(source);
    });
  };

  // create map of private identifiers to be inlined
  var inlineMap = _.transform(_.difference(buildFuncs, privateFuncs), function(result, funcName) {
    var inlinees = getInlinees(funcName);
    if (!_.isEmpty(inlinees)) {
      result[funcName] = inlinees;
    }
  }, createMap());

  // exclude `_.noConflict` and "Chain" functions when exporting for npm
  if (isNpm) {
    identifiers = _.difference(identifiers, ['noConflict'], categoryMap.Chaining, categoryFluxMap.Chaining);
  }
  // create modules for each identifier, except `lodash` because it's built separately
  _.each(_.without(identifiers, 'lodash'), function(identifier) {
    var categories = getCategories(identifier, funcDepMap);
    if (_.isEmpty(categories)) {
      categories.push(null);
    }
    _.each(isNpm ? categories.slice(0, 1) : categories, function(category) {
      var isInternal = isPrivate(identifier),
          moduleName = isNpm ? 'lodash.' + (isInternal ? '_' : '') + identifier.toLowerCase() : identifier,
          modulePath = isNpm ? moduleName : getModulePath(identifier, category, funcDepMap);

      var inlinees = [identifier];
      push.apply(inlinees, inlineMap[identifier]);

      var inlineFuncs = _.intersection(allFuncs, inlinees),
          inlineObjs = _.intersection(includeObjs, inlinees),
          inlineVars = _.intersection(includeVars, inlinees);

      var depNames = _.difference(_.reduce(inlinees, function(result, identifier) {
        return _.union(result,
          getDependencies(identifier, funcDepMap, true),
          objDepMap[identifier],
          varDepMap[identifier]
        );
      }, []), inlinees);

      // deep inline additional dependencies when exporting for npm
      if (isNpm) {
        _.each(_.intersection(depNames, inlineableFuncs), function(identifier) {
          var deps = getDependencies(identifier, funcDepMap);
          deps.push(identifier);

          inlineFuncs = _.union(inlineFuncs, _.intersection(deps, inlineableFuncs));
          inlineVars = _.union(inlineVars, varDepMap[identifier]);

          deps = _.difference(deps, inlineFuncs);
          depNames = _.difference(depNames, inlineFuncs);
          depNames = _.union(depNames, deps, objDepMap[identifier]);
        });
      }
      depNames.sort();

      state.outputPath = path.join(outputPath, modulePath, (isNpm ? 'index' : identifier) + '.js');
      state.buildFuncs = state.includeFuncs = inlineFuncs;
      state.includeObjs = inlineObjs;
      state.includeVars = inlineVars;

      build(state, function(data) {
        var iife = [],
            source = data.source,
            unusedDeps = getUnusedDeps(source, depNames);

        depNames = _.difference(depNames, unusedDeps);
        removedDeps[identifier] = unusedDeps;

        var depPaths = isNpm
          ? _.map(depNames, function(depName) { return 'lodash.' + (isPrivate(depName) ? '_' : '') + depName.toLowerCase(); })
          : getDepPaths(depNames, modulePath, funcDepMap);

        if (isAMD) {
          iife.push(
            'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depNames.join(', ') + ') {',
            '%output%',
            '  return ' + identifier + ';',
            '});'
          );
        }
        else if (isES6) {
          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ';\n' : '') +
                'import ' + depName + " from '" + depPath + "'";
            }, '') + ';',
            '%output%',
            'export default ' + identifier + ';'
          );
        }
        else {
          iife.push(
            _.reduce(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              return result + (result ? ',\n    ' : 'var ') +
                depName + " = require('" + depPath + "')" +
                (isCommonJS ? '.' + depName : '');
            }, '') + ';',
            '%output%',
            (isCommonJS ? 'exports.' + identifier : 'module.exports') + ' = ' + identifier + ';'
          );
        }
        if (isNpm) {
          var keywords = isInternal
            ? []
            : ['functional', 'lodash', 'lodash-modularized', 'server', 'util'];

          var type = _.contains(objDependencies, identifier)
            ? 'object'
            : (_.contains(varDependencies, identifier) ? 'variable' : 'function');

          var moduleDesc = 'The ' +
            (isInternal ? 'internal ' : '') +
            'Lo-Dash ' + type + ' `' + (isInternal ? '' : '_.') +
            identifier + '` as a Node.js module generated by lodash-cli.';

          var markdownDesc = moduleDesc
            .replace('Lo-Dash', '[Lo-Dash](http://lodash.com/)')
            .replace('Node.js', '[Node.js](http://nodejs.org/)')
            .replace('lodash-cli', '[lodash-cli](https://npmjs.org/package/lodash-cli)')
            .replace(/`_\.([$\w]+)`/, '[$&](http://lodash.com/docs#$1)');

          var templateData = {
            'name': moduleName,
            'version': version,
            'description': moduleDesc,
            'keywords': keywords,
            'dependencies': _.transform(depPaths, function(result, depPath) {
              result[depPath] = '~' + version;
            }, {})
          };

          fs.writeFileSync(path.join(outputPath, modulePath, 'package.json'), _.template(packageTemplate, templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'LICENSE.txt'), _.template(licenseTemplate, templateData), 'utf-8');
          fs.writeFileSync(path.join(outputPath, modulePath, 'README.md'), _.template(readmeTemplate, _.defaults({ 'description': markdownDesc }, templateData)), 'utf-8');
        }
        if (!isAMD) {
          source = trimIndent(source);
        }
        source = removeLicenseTag(source);
        source = replaceIIFE(source, iife.join('\n'));

        data.source = source;
        buildCallback(data);
      });
    });
  });

  // create lodash module
  (function() {
    if (isNpm || !_.contains(buildFuncs, 'lodash')) {
      return;
    }
    var identifier = 'lodash',
        basename = identifier,
        modulePath = getModulePath(identifier, funcDepMap);

    var categories = _.uniq(_.compact(_.map(identifiers, _.compose(_.first, _.partial(getCategories, _, funcDepMap))))).sort(),
        categoryDeps = _.invoke(categories, 'toLowerCase'),
        categoryDepPaths = _.map(categoryDeps, function(depName) { return './' + depName; });

    var deps = getDependencies(identifier, funcDepMap, true)
      .concat(objDepMap[identifier] || empty)
      .concat(varDepMap[identifier] || empty)
      .sort();

    if (isAMD) {
      basename = 'main';
    }
    else if (!isES6) {
      basename = 'index';
    }
    state.buildFuncs = state.includeFuncs = [identifier];
    state.includeObjs = state.includeVars = empty;
    state.outputPath = path.join(outputPath, modulePath, basename + '.js');

    build(state, function(data) {
      var source = data.source;

      // remove unneeded method and alias assignments
      _.each(_.difference(allFuncs, buildFuncs), function(funcName) {
        source = removeMethodAssignment(source, funcName);
      });

      // add category namespaces to each lodash function assignment
      source = source.replace(/(lodash(?:\.prototype)?\.[$\w]+\s*=\s*)([$\w]+)/g, function(match, prelude, identifier) {
        if (_.contains(deps, identifier)) {
          return match;
        }
        var category = _.first(getCategories(identifier, funcDepMap));
        return prelude + (category ? category.toLowerCase() + '.' : '') + identifier;
      });

      // add `lodash.support` and `lodash.templateSettings` assignment
      source = source.replace(/^ *lodash\.VERSION\b.+\n/m, function(match) {
        var code = [
          '',
          '  lodash.support = support;'
        ];

        if (_.contains(identifiers, 'templateSettings')) {
          code.push('  (lodash.templateSettings = utilities.templateSettings).imports._ = lodash;');
        }
        code.push('');
        return match + code.join('\n');
      });

      // wrap `_.mixin`
      source = source.replace(/^ *lodashWrapper\.prototype\s*=[^;]+;\n/m, function(match) {
        var code = [
          '',
          '  // wrap `_.mixin` so it works when provided only one argument',
          '  mixin = (function(func) {'
        ];

        if (isUnderscore) {
          code.push(
            '    return function(object, source) {',
            '      if (!source) {',
            '        source = object;',
            '        object = lodash;',
            '      }',
            '      return func(object, source);'
          );
        } else {
          code.push(
            '    var functions = objects.functions;',
            '    return function(object, source, options) {',
            '      if (!source || (!options && !functions(source).length)) {',
            '        if (options == null) {',
            '          options = source;',
            '        }',
            '        source = object;',
            '        object = this;',
            '      }',
            '      return func(object, source, options);'
          );
        }
        code.push(
          '    };',
          '  }(mixin));',
          ''
        );
        return match + code.join('\n');
      });

      var unusedDeps = getUnusedDeps(source, deps);
      deps = _.difference(deps, unusedDeps);
      removedDeps[identifier] = unusedDeps;

      var iife = [],
          depNames = categoryDeps.concat(deps),
          depArgs = depNames.join(', '),
          depPaths = categoryDepPaths.concat(getDepPaths(deps, modulePath, funcDepMap));

      if (isAMD) {
        iife.push(
          'define([' + (_.isEmpty(depPaths) ? '' : "'" + depPaths.join("', '") + "'") + '], function(' + depArgs + ') {',
          '%output%',
          '  return lodash;',
          '});'
        );
      }
      else if (isES6) {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ';\n' : '') +
              'import ' + depName + " from '" + depPath + "'";
          }, '') + ';',
          '%output%',
          'export default ' + identifier + ';'
        );
      }
      else {
        iife.push(
          _.reduce(depPaths, function(result, depPath, index) {
            var depName = depNames[index];
            return result + (result ? ',\n    ' : 'var ') +
              depName + " = require('" + depPath + "')" +
              (isCommonJS && !_.contains(categoryDepPaths, depPath) ? '.' + depName : '');
          }, '') + ';',
          '%output%',
          (isCommonJS ? 'exports._' : 'module.exports') + ' = ' + identifier + ';'
        );
      }
      if (!isAMD) {
        source = trimIndent(source);
      }
      source = replaceIIFE(source, iife.join('\n'));

      data.source = source;
      buildCallback(data);
    });
  }());

  // create category modules
  (function() {
    if (isNpm) {
      return;
    }
    var categories = _.uniq(_.compact(_.flatten(_.map(identifiers, _.partial(getCategories, _, funcDepMap)))));

    _.each(categories, function(category) {
      state.buildFuncs = state.includeFuncs = state.includeObjs = state.includeVars = empty;
      state.outputPath = path.join(outputPath, category.toLowerCase() + '.js');

      build(state, function(data) {
        var iife = [],
            source = data.source;

        var depNames = _.intersection(getNamesByCategory(category), _.without(identifiers, 'lodash')).sort(),
            depPaths = getDepPaths(depNames, null, funcDepMap);

        if (isAMD) {
          iife.push(
            "define(['" + depPaths.join("', '") + "'], function(" + depNames.join(', ') + ') {',
            '%output%',
            '  return {',
            _.transform(depNames, function(result, depName) {
              _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                result.push( "    '" + otherName + "': " + depName);
              });
            })
            .sort()
            .join(',\n'),
            '  };',
            '});'
          );
        }
        else {
          iife.push('%output%');

          if (isES6) {
            push.apply(iife, _.transform(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                result.push('export { default as ' + otherName + " } from '" + depPath + "';");
              });
            })
            .sort());
          }
          else if (isCommonJS) {
            push.apply(iife, _.transform(depPaths, function(result, depPath, index) {
              var depName = depNames[index];
              _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                result.push('exports.' + otherName + " = require('" + depPath + "')." + depName + ';');
              });
            })
            .sort());
          }
          else {
            iife.push(
              'module.exports = {',
              _.transform(depPaths, function(result, depPath, index) {
                var depName = depNames[index];
                _.each(getAliases(depName, funcDepMap).concat(depName), function(otherName) {
                  result.push("  '" + otherName + "': require('" + depPath + "')");
                });
              })
              .sort()
              .join(',\n'),
              '};'
            );
          }
        }
        if (!isAMD) {
          source = trimIndent(source);
        }
        source = removeLicenseTag(source);
        source = replaceIIFE(source, iife.join('\n'));

        data.source = source;
        buildCallback(data);
      });
    });
  }());

  if (!isSilent) {
    // warn of removed dependencies
    _.forOwn(removedDeps, function(depNames, identifier) {
      if (!_.isEmpty(depNames)) {
        var plural = _.size(depNames) > 1;
        console.warn('Warning: Removed ' + (plural ? '' : 'an ') + 'unused dependenc' + (plural ? 'ies' : 'y') + ' from `' + identifier + '`: ' + depNames.join(', '));
      }
    });
  }
  if (callback) {
    callback({ 'outputPath': fs.realpathSync(outputPath) });
  }
}

/**
 * Compiles template files based on the provided build state extending
 * `_.templates` with precompiled templates named after each file's basename.
 *
 * @private
 * @param {Object} state The build state object.
 * @returns {string} Returns the compiled source.
 */
function buildTemplate(state) {
  var glob = require('glob'),
      moduleId = state.moduleId || 'lodash',
      isStandalone = moduleId == 'none',
      pattern = state.templatePattern,
      settings = state.templateSettings;

  pattern = path.normalize(pattern || path.join(cwd, '*.jst'));

  var hr = '  /*----------------------------------------------------------------------------*/';

  var source = [
    ';(function() {',
    '  var undefined;',
    '',
    '  var objectTypes = {',
    "    'function': true,",
    "    'object': true",
    '  };',
    '',
    '  var root = (objectTypes[typeof window] && window) || this;',
    '',
    '  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;',
    '',
    '  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;',
    '',
    "  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;",
    '  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {',
    '    root = freeGlobal;',
    '  }',
    '',
    '  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;',
    ''
  ];

  if (isStandalone) {
    build(['exports=none', 'include=escape', 'iife=%output%', '-d', '-s'], function(data) {
      var escapeSource = data.source;
      escapeSource = removeHeader(escapeSource);
      escapeSource = removeFunction(escapeSource, 'lodash');
      escapeSource = removeAssignments(escapeSource);
      escapeSource = cleanupSource(escapeSource);

      source.push(
        '',
        escapeSource,
        '',
        "  var _ = { 'escape': escape };",
        ''
      );
    });
  }
  else {
    source.push(
      '  var _ = root._ || {};',
      ''
    );
  }
  source.push(
    hr,
    ''
  );

  glob(pattern, { 'sync': true }, function(exception, filePaths) {
    if (exception) {
      throw exception;
    }
    var dirname = path.dirname(pattern);
    if (dirname == '.') {
      dirname = '';
    }
    var basePath = (dirname + path.sep).replace(RegExp('(^|' + path.sepEscaped + ')\\*\\*.*$'), '$1'),
        insertAt = source.length,
        templates = createMap();

    _.each(filePaths, function(filePath) {
      var string = fs.readFileSync(filePath, 'utf8'),
          precompiled = cleanupCompiled(getFunctionSource(_.template(string, null, settings), 2));

      // glob uses *nix path separators even on Windows
      // https://github.com/isaacs/node-glob#windows
      var clipped = filePath.slice(dirname ? basePath.length : 0).replace(/\..*$/, ''),
          props = clipped.split('/');

      // create namespace objects
      _.reduce(props, function(object, key) {
        return object[key] || (object[key] = createMap());
      }, templates);

      // escape namespace property names
      props = _.map(props, function(key) {
        return "['" + key.replace(/['\n\r\t]/g, '\\$&') + "']";
      });

      // add template assignment to `source`
      source.push('  templates' + props.join('') + ' = ' + precompiled + ';', '');
    });

    // add the initial `_.templates` object to `source`
    source.splice(insertAt, 0, '  var templates = ' +
      JSON.stringify(templates, null, 4)
        .replace(/^ *}$/m, '  $&')
        .replace(/'/g, "\\'")
        .replace(/([^\\])"/g, "$1'") +
      ';',
      ''
    );
  });

  source.push(
    hr,
    '',
    "  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {"
  );

  if (isStandalone) {
    source.push(
      '    define(function() {',
      '      return templates;'
    );
  }
  else {
    source.push(
      "    define(['" + moduleId + "'], function(lodash) {",
      '      _ = lodash;',
      '      lodash.templates = lodash.extend(lodash.templates || {}, templates);'
    );
  }
  source.push(
    '    });',
    '  }',
    '  else if (freeExports && freeModule) {'
  );

  if (!isStandalone) {
    source.push("    _ = require('" + moduleId + "');");
  }
  source.push(
    '    if (moduleExports) {',
    '      (freeModule.exports = templates).templates = templates;',
    '    } else {',
    '      freeExports.templates = templates;',
    '    }'
  );

  if (isStandalone) {
    source.push(
      '  }',
      '  else {',
      '    root.templates = templates;',
      '  }'
    );
  }
  else {
    source.push(
      '  }',
      '  else if (_) {',
      '    _.templates = _.extend(_.templates || {}, templates);',
      '  }'
    );
  }
  source.push('}.call(this));');

  return source.join('\n');
}

/**
 * Removes unnecessary semicolons and whitespace from compiled code.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupCompiled(source) {
  return stringFree(source, function(source) {
    return source
      .replace(/\b(function) *(\()/g, '$1$2')
      .replace(/([{}]) *;/g, '$1');
  });
}

/**
 * Removes unnecessary comments, and whitespace.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function cleanupSource(source) {
  return stringFree(source, function(source) {
    return source
      // consolidate consecutive horizontal rule comment separators
      .replace(/(?:\s*\/\*-+\*\/\s*){2,}/g, function(separators) {
        var indent = separators.match(/^\s*/)[0];
        return indent + separators.slice(separators.lastIndexOf('/*'));
      })
      // remove unneeded single line comments
      .replace(/(\{\s*)?(\n *\/\/.*)(\s*\})/g, function(match, prelude, comment, postlude) {
        return (!prelude && postlude) ? postlude : match;
      })
      // remove unneeded horizontal rule comment separators
      .replace(/(\{\s*\n) *\/\*-+\*\/\n|^ *\/\*-+\*\/\n(\s*\})/gm, '$1$2')
      // remove trailing horizontal rule comment separators
      .replace(/\s*\/\*-+\*\/\s*$/, '')
      // remove lines with just spaces and semicolons
      .replace(/^ *;\n/gm, '')
      // remove trailing spaces from lines
      .replace(/ *$/gm, '')
      // consolidate multiple newlines
      .replace(/\n{3,}/g, '\n\n')
      // remove leading empty lines
      .replace(/^ *\n+/, '')
      // add trailing newline
      .trimRight() + '\n';
  });
}

/**
 * Creates a map object. If a `properties` object is provided its own
 * enumerable properties are assigned to the created object.
 *
 * @private
 * @param {Object} [properties] The properties to assign to the object.
 * @returns {Object} Returns the new object.
 */
function createMap(properties) {
  return _.assign(Object.create(null), properties);
}

/**
 * The default callback used for `build` invocations.
 *
 * @private
 * @param {Object} data The data for the given build.
 *  gzip - The gzipped output of the built source
 *  outputPath - The path where the built source is to be written
 *  source - The built source output
 *  sourceMap - The source map output
 */
function defaultBuildCallback(data) {
  var outputPath = data.outputPath,
      sourceMap = data.sourceMap;

  if (outputPath) {
    fs.writeFileSync(outputPath, data.source, 'utf8');
    if (sourceMap) {
      fs.writeFileSync(path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.map'), sourceMap, 'utf8');
    }
  }
}

/**
 * Writes the help message to standard output.
 *
 * @private
 */
function displayHelp() {
  console.log([
    'Usage:',
    '  lodash [commands] [options]',
    '',
    'Commands:',
    '',
    '  backbone     Build with only functions required by Backbone',
    '  compat       Build with support for old & new environments (default)',
    '  modern       Build tailored for newer environments with ES5 support',
    '  strict       Build with ES5 strict mode enabled',
    '  underscore   Build tailored for projects already using Underscore',
    '  modularize   Splits Lo-Dash into modules',
    '',
    '  include=..   Comma separated function/category names to include in the build',
    '',
    '  minus=..     Comma separated function/category names to remove from the build',
    '',
    '  plus=..      Comma separated function/category names to add to the build',
    '',
    '  category=..  Comma separated categories of functions to include in the build',
    '               (i.e. arrays, chaining, collections, functions,',
    '               objects, & utilities)',
    '',
    '  exports=..   Comma separated names of ways to export the `lodash` function.',
    '               (i.e. amd, commonjs, es6, global, node, npm, & none)',
    '',
    '  iife=..      Code to replace the IIFE that wraps Lo-Dash',
    '               (e.g. `lodash iife="!function(){%output%}()"`)',
    '',
    '  template=..  File path pattern used to match template files to precompile',
    '               (e.g. `lodash template=./*.jst`)',
    '',
    '  settings=..  Template settings used when precompiling templates',
    '               (e.g. `lodash settings="{interpolate:/{{([\\s\\S]+?)}}/g}"`)',
    '',
    '  moduleId=..  The AMD module ID used to export Lo-Dash in Lo-Dash builds or',
    '               the module ID used to include Lo-Dash in compiled templates.',
    '',
    '               Use none as the module ID to create compiled templates without',
    '               a dependency on Lo-Dash.',
    '',
    '  All commands except `backbone`, `modern`, & `underscore` may be combined.',
    '',
    '  The `exports` values es6 & npm may only be used in conjunction with',
    '  the `modularize` command. The es6 `exports` option is experimental & may',
    '  be subject to change.',
    '',
    '  Unless specified by `-o` or `--output` all files created are saved to the',
    '  current working directory.',
    '',
    'Options:',
    '',
    '  -c, --stdout      Write output to standard output',
    '  -d, --debug       Write only the non-minified development output',
    '  -h, --help        Display help information',
    '  -m, --minify      Write only the minified production output',
    '  -o, --output      Write output to a given path/filename',
    '  -p, --source-map  Generate a source map using an optional source map URL',
    '  -s, --silent      Skip status updates normally logged to the console',
    '  -V, --version     Output current version of Lo-Dash',
    ''
  ].join('\n'));
}

/**
 * Gets the aliases associated with a given function name.
 *
 * @private
 * @param {string} funcName The name of the function to get aliases for.
 * @param {Object} [depMap] The dependency map used to validate aliases.
 * @returns {Array} Returns an array of aliases.
 */
function getAliases(funcName, depMap) {
  var aliases = _.has(realToAliasMap, funcName) && realToAliasMap[funcName];
  return _.reject(aliases, _.partial(_.has, depMap || funcDependencyMap));
}

/**
 * Gets the categories of the given identifier.
 *
 * @private
 * @param {string} identifier The identifier to query.
 * @param {Object} [depMap] The dependency map used to resolve the identifier.
 * @returns {Array} Returns the array of categories.
 */
function getCategories(identifier, depMap) {
  var result = [];
  identifier = getRealName(identifier, depMap);

  _.each([categoryMap, categoryFluxMap], function(catMap) {
    _.forOwn(catMap, function(identifiers, category) {
      if (_.contains(identifiers, identifier)) {
        result.push(category);
      }
    });
  });
  return result;
}

/**
 * Gets the `baseCreate` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getBaseCreateFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if *\((?:!nativeCreate)\b[\s\S]+?\n *}\(\)\);\n\1}\n/m), 0, '');
}

/**
 * Resolves the path of the given module dependency. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {string} depName The name of the dependency.
 * @param {string} [fromPath=''] The path to resolve the dependency relative to.
 * @param {Object} [depMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the dependency path.
 */
function getDepPath(depName, fromPath, depMap) {
  var sep = '/',
      toPath = getModulePath(depName, depMap),
      relative = path.relative(fromPath || '', toPath).replace(RegExp(path.sepEscaped, 'g'), sep);

  if (relative.charAt(0) != '.') {
    relative = '.' + (relative ? sep + relative : '');
  }
  return relative + sep + depName;
}

/**
 * Resolves the paths of the given module dependencies. If `fromPath` is
 * provided the resolved path will be relative to `fromPath`.
 *
 * @private
 * @param {Array} depNames The array dependency names.
 * @param {string} [fromPath=''] The path to resolve dependencies relative to.
 * @param {Object} [depMap] The dependency map used to resolve identifiers.
 * @returns {string[]} Returns the dependency paths.
 */
function getDepPaths(depNames, fromPath, depMap) {
  return _.map(depNames, _.partial(getDepPath, _, fromPath, depMap));
}

/**
 * Gets an array of depenants for the given function name(s).
 *
 * @private
 * @param {string} funcName A function name or array of function names.
 * @param {Object} [depMap] The dependency map used to look up dependants.
 * @param {boolean} [isShallow=false] A flag to specify getting only the immediate dependants.
 * @param- {Array} [stackA=[]] Internally used track queried function names.
 * @returns {Array} Returns an array of function dependants.
 */
function getDependants(funcName, depMap, isShallow, stack) {
  var funcNames = _.isArray(funcName) ? funcName : [funcName];
  depMap || (depMap = funcDependencyMap);
  stack || (stack = []);

  // iterate over the dependency map, adding names of functions that have `funcName` as a dependency
  return _.uniq(_.transform(depMap, function(result, depNames, otherName) {
    if (!_.contains(stack, otherName) &&
        _.some(funcNames, _.partial(_.contains, depNames, _, 0))) {
      result.push(otherName);
      if (!isShallow) {
        stack.push(otherName);
        push.apply(result, getDependants(otherName, depMap, isShallow, stack));
      }
    }
  }, []));
}

/**
 * Gets an array of dependencies for a given function name. If an array of
 * dependencies is provided, it will return an array containing the given
 * dependencies plus any additional detected sub-dependencies.
 *
 * @private
 * @param {string|string[]} funcName A function name or array of dependencies to query.
 * @param {Object} [depMap] The dependency map used to look up dependants.
 * @param {boolean} [isShallow=false] A flag to specify getting only the immediate dependencies.
 * @param- {Array} [stackA=[]] Internally used track queried function names.
 * @returns {Array} Returns an array of function dependencies.
 */
function getDependencies(funcName, depMap, isShallow, stack) {
  var depNames = _.isArray(funcName) ? funcName : depMap[funcName];
  depMap || (depMap = funcDependencyMap);

  if (!_.size(depNames)) {
    return [];
  }
  if (isShallow) {
    return depNames.slice();
  }
  stack || (stack = []);

  // recursively accumulate the dependencies of the `funcName` function, and
  // the dependencies of its dependencies, and so on
  return _.uniq(_.transform(depNames, function(result, otherName) {
    if (!_.contains(stack, otherName)) {
      stack.push(otherName);
      result.push(otherName);
      push.apply(result, getDependencies(otherName, depMap, isShallow, stack));
    }
  }));
}

/**
 * Gets the formatted source of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @param {number|string} [indent=0] The level to indent.
 * @returns {string} Returns the formatted source.
 */
function getFunctionSource(func, indent) {
  var source = func.source || (func + ''),
      srcIndent = getIndent(source),
      forceIndent = _.size(source.match(RegExp('^' + srcIndent + '}', 'gm'))) > 1;

  indent || (indent = '');
  if (typeof indent == 'number') {
    indent = _.repeat(' ', indent);
  }
  // remove any existing indent
  if (srcIndent) {
    source = source.replace(RegExp('^' + srcIndent, 'gm'), '');
  }
  // set indent of source
  return indent + source.replace(/\n(?:.*)/g, function(match, index) {
    var prelude = '\n' + indent;
    match = match.slice(1);
    if (forceIndent) {
      prelude += (match == '}' && !_.contains(source, '}', index + 2) ? '' : '  ');
    }
    return prelude + match;
  });
}

/**
 * Gets the copyright/license header of `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the copyright/license header.
 */
function getHeader(source) {
  return _.result(/^(?:\s*\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\s*\/\/.*)*\n/.exec(source), 0, '');
}

/**
 * Gets the indent of the given function.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the indent.
 */
function getIndent(func) {
  return /^ *(?=\S)/m.exec(func.source || func)[0];
}

/**
 * Gets the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArgumentsFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if *\((?:!support\.argsClass|!isArguments)\b[\s\S]+?\n *};\n\1}\n/m), 0, '');
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsArrayFork(source) {
  return matchFunction(source, 'isArray')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsElementFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if *\(!support\.dom\b[\s\S]+?\n *};\n\1}\n/m), 0, '');
}

/**
 * Gets the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getIsFunctionFork(source) {
  return _.result(source.match(/^(?: *\/\/.*\n)*( *)if *\(isFunction\(\/x\/[\s\S]+?\n *};\n\1}\n/m), 0, '');
}

/**
 * Gets the Lo-Dash method assignments snippet from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the method assignments snippet.
 */
function getMethodAssignments(source) {
  return _.result(source.match(/\n\n(?: *\/\/.*\n)* *lodash\.[$\w]+\s*=[\s\S]+lodash\.[$\w]+\s=.+/), 0, '');
}

/**
 * Resolves the module path of the given identifier.
 *
 * @private
 * @param {string} identifier The module identifier.
 * @param {string} [category] The category of the identifier.
 * @param {Object} [depMap] The dependency map used to resolve identifiers.
 * @returns {string} Returns the module path.
 */
function getModulePath(identifier, category, depMap) {
  if (topLevel[identifier]) {
    return '';
  }
  if (_.isObject(category)) {
    depMap = category;
    category = null;
  }
  if (!category) {
    category = _.first(getCategories(identifier, depMap));
  }
  return (category || 'internals').toLowerCase();
}

/**
 * Gets the names of identifiers in `source` that belong to the given category.
 *
 * @private
 * @param {string} category The category to filter by.
 * @returns {Array} Returns a new array of names.
 */
function getNamesByCategory(category) {
  return _.union(categoryMap[category], categoryFluxMap[category]);
}

/**
 * Gets the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getNowFork(source) {
  return matchFunction(source, 'now')
    .replace(/^[\s\S]+?(?=\|\|)/, '')
    .replace(/[;\s]+$/, '');
}

/**
 * Gets the value of a given name from the `options` array. If no value is
 * available the `defaultValue` is returned.
 *
 * @private
 * @param {Array} options The options array to inspect.
 * @param {string} name The name of the option.
 * @param {*} defaultValue The default option value.
 * @returns {*} Returns the option value.
 */
function getOption(options, name, defaultValue) {
  var isArr = _.isArray(defaultValue);
  return _.reduce(options, function(result, value) {
    if (isArr) {
      value = optionToArray(name, value);
      return _.isEmpty(value) ? result : value;
    }
    value = optionToValue(name, value);
    return value == null ? result : value;
  }, defaultValue);
}

/**
 * Gets the real name, not alias, of a given function name.
 *
 * @private
 * @param {string} funcName The name of the function to resolve.
 * @param {Object} [depMap] The dependency map used to validate the real name.
 * @returns {string} Returns the real function name.
 */
function getRealName(funcName, depMap) {
  return (
    !_.has(depMap || funcDependencyMap, funcName) &&
    _.has(aliasToRealMap, funcName) &&
    aliasToRealMap[funcName]
  ) || funcName;
}

/**
 * Gets the `setData` fork from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the fork.
 */
function getSetDataFork(source) {
  return _.result(matchFunction(source, 'setData').match(/!defineProperty[^:]+:\s*/), 0, '');
}

/**
 * Creates a sorted array of all variables defined outside of Lo-Dash functions.
 *
 * @private
 * @param {string} source The source to process.
 * @param {boolean} [isShallow=false] A flag to specify looking for varaibles one closure deep.
 * @returns {Array} Returns a new array of variable names.
 */
function getVars(source, isShallow) {
  var indentA = isShallow ? ' {2}' : ' {2,4}',
      indentB = isShallow ? ' {6}' : ' {6,8}';

  source = removeStrings(removeComments(source));

  // remove all functions except `runInContext`
  source = source
    .replace(/^( *)function (?!runInContext)[\s\S]+?\{\n[\s\S]+?\n\1}\n/gm, '')
    .replace(/^( *)(?:var )?[$\w]+ *=.*?(?:create[A-Z][a-z]+|template)\((?:.+|[\s\S]+?\n\1(?:\S.*?)?)\);\n/gm, '')
    .replace(/^( *)(?:var )?[$\w]+ *= *function\b[\s\S]+?\{\n[\s\S]+?\n\1};\n/gm, '');

  var result = _.reduce([
    // match a varaible at the start of a declaration list
    indentA + 'var ([$\\w]+) *=.+?,\\n(?= *[$\\w]+ *=)',
    // match a variable declaration in a declaration list
    indentB + '([$\\w]+) *=.+?[,;]\\n',
    // match a variable that is not part of a declaration list
    '(' + indentA + ')var ([$\\w]+) *(?:|= *(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1[^\\n ]+?));\\n'
  ], function(result, reSource) {
    source = source.replace(RegExp('^' + reSource, 'gm'), function(match, indent, varName) {
      result.push(typeof varName == 'number' ? indent : varName);
      return '';
    });
    return result;
  }, []);

  return _.uniq(result).sort();
}

/**
 * Checks if `source` is a function snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {boolean} Returns `true` for a function snippet, else `false`.
 */
function isFunctionSnippet(source) {
  var header = getHeader(source);
  if (header && reFuncTag.test(header)) {
    return true;
  }
  return reFuncSnippet.test(source.replace(header, ''));
}

/**
 * Checks if `funcName` is a private function.
 *
 * @private
 * @param {string} funcName The name of the function.
 * @returns {boolean} Returns `true` if the function is private, else `false`.
 */
function isPrivate(funcName) {
  return _.contains(privateFuncs, funcName);
}

/**
 * Checks if the variable `varName` is used in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable.
 * @param {boolean} [isShallow=false] A flag to specify looking for varaibles one closure deep.
 * @returns {boolean} Returns `true` if the variable is used, else `false`.
 */
function isVarUsed(source, varName, isShallow) {
  var match = matchVar(source, varName, isShallow);
  if (!match) {
    return false;
  }
  // remove the variable assignment from the source
  source = source.replace(match, '');
  return RegExp('[^.$"\'\\w]' + varName + '\\b(?!\\s*=)').test(source);
}

/**
 * Searches `source` for a `funcName` function declaration, expression, or
 * assignment and returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} funcName The name of the function to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched function snippet.
 */
function matchFunction(source, funcName, leadingComments) {
  var result = _.reduce([
    // match a function declaration
    '( *)function ' + funcName + '\\b[\\s\\S]+?\\n\\3}\\n',
    // match variable declarations using `createAggregator`, `createCompounder`, or `template`
    '( *)var ' + funcName + ' *=.*?(?:create[A-Z][a-z]+|template)\\((?:.+|[\\s\\S]+?\\n\\3(?:\\S.*?)?)\\);\\n',
    // match a variable declaration with function expression
    '( *)var ' + funcName + ' *=.*?function\\b[\\s\\S]+?\{\\n[\\s\\S]+?\\n\\3}(?:\\(\\)\\))?;\\n',
    // match a simple variable declaration
    ' *var ' + funcName + ' *=.+?;\\n'
  ], function(result, reSource) {
    return result || (result = source.match(RegExp(
      '^(' + multilineComment + ')' +
      '('  + reSource + ')'
    , 'm')));
  }, null);

  if (result && isFunctionSnippet(result[0])) {
    return (leadingComments ? result[1] : '') + result[2];
  }
  return '';
}

/**
 * Searches `source` for a Lo-Dash property, of the given property name, and
 * returns the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} propName The name of the property to match.
 * @param {boolean} [leadingComments] A flag to specify including leading comments.
 * @returns {string} Returns the matched property snippet.
 */
function matchProp(source, propName, leadingComments) {
  return _.result(source.match(RegExp(
    '^' + (leadingComments ? multilineComment : '') +
    '(?: {2,4}var ' + propName + '\\b.+|(?: *|.*?=\\s*)lodash\\._?' + propName + '\\s*)=[\\s\\S]+?' +
    '(?:\\(function\\b[\\s\\S]+?\\}\\([^)]*\\)\\);\\n(?=\\n)|' +
    '[;}]\\n(?=\\n(?!\\s*\\(func)))'
  , 'm')), 0, '');
}

/**
 * Searches `source` for a `varName` variable assignment and returns
 * the matched snippet.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to match.
 * @param {boolean} [isShallow=false] A flag to specify looking for varaibles one closure deep.
 * @returns {string} Returns the matched variable snippet.
 */
function matchVar(source, varName, isShallow) {
  var indentA = isShallow ? ' {2}' : ' {2,4}',
      indentB = isShallow ? ' {6}' : ' {6,8}';

  var reSources = [
    // match a varaible at the start of a declaration list
    indentA + 'var ' + varName + ' *=.+?,\\n(?= *[$\\w]+ *=)',
    // match a variable declaration in a declaration list
    indentB + varName + ' *=.+?[,;]\\n',
    // match a variable that is not part of a declaration list
    '(' + indentA + ')var ' + varName + ' *(?:|= *(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1[^\\n ]+?));\\n'
  ];

  // match complex variable assignments
  if (varName != 'freeGlobal' && _.contains(complexVars, varName)) {
    reSources = [
      indentA + 'var '  + varName + ' *=[\\s\\S]+?' +
      '(?:\\(function\\b[\\s\\S]+?\\}\\([^)]*\\)\\);\\n(?=\\n)|' +
      '[;}]\\n(?=\\n(?!\\s*\\(func)))'
    ];
  }
  return _.reduce(reSources, function(result, reSource) {
    return result || (result = source.match(RegExp(
      '^' + reSource
    , 'm'))) && result[0];
  }, null) || '';
}

/**
 * Converts a comma separated option value into an array.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {Array} Returns the new converted array.
 */
function optionToArray(name, string) {
  return _.compact(_.invoke((optionToValue(name, string) || '').split(/, */), 'trim'));
}

/**
 * Extracts the option value from an option string.
 *
 * @private
 * @param {string} name The name of the option to inspect.
 * @param {string} string The options string.
 * @returns {string|undefined} Returns the option value, else `undefined`.
 */
function optionToValue(name, string) {
  var result = (result = string.match(RegExp('^' + name + '(?:=([\\s\\S]+))?$'))) && (result[1] ? result[1].trim() : true);
  if (result === 'false') {
    return false;
  }
  return result || undefined;
}

/**
 * Removes all Lo-Dash assignments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeAssignments(source) {
  // remove method and intermediate assignments
  source = removeMethodAssignments(source);
  source = source.replace(/(=\s*)lodash\.[$\w]+\s*=\s*/g, '$1');
  return source;
}

/**
 * Removes the `baseCreate` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeBaseCreateFork(source) {
  return source.replace(getBaseCreateFork(source), '');
}

/**
 * Removes support for Lo-Dash wrapper chaining in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeChaining(source) {
  source = removeMixinCalls(source);
  source = removeSpliceObjectsFix(source);

  // remove all `lodash.prototype` additions
  source = source
    .replace(/^(?: *\/\/.*\n)*( *)baseForOwn\(lodash,[\s\S]+?\n\1}.+\n/gm, '')
    .replace(/^(?: *\/\/.*\n)*( *)arrayEach\(\['[\s\S]+?\n\1}.+\n/gm, '')
    .replace(/^(?: *\/\/.*\n)* *lodash\.prototype\.[\s\S]+?;\n/gm, '');

  // replace `lodash` with a simpler version
  source = replaceFunction(source, 'lodash', [
    'function lodash() {',
    '  // no operation performed',
    '}'
  ].join('\n'));

  return source;
}

/**
 * Removes all comments from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeComments(source) {
  return source.replace(/^ *(?:\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/|\/\/.+)\n/gm, '');
}

/**
 * Removes ES5 specific optimizations from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeEsOptimization(source) {
  source = removeSupportProp(source, 'funcDecomp');
  source = removeSupportProp(source, 'funcNames');

  // remove `expando` logic and `setData` function calls
  _.each(['baseBind', 'baseCreateCallback', 'baseCreateWrapper', 'createWrapper'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match
        .replace(/^(?: *\/\/.*\n)*( *)var data *=[\s\S]+?\n\1}\n/m, '')
        .replace(/^(?: *\/\/.*\n)*( *)if *\(data\b[\s\S]+?\n\1}\n/m, '')
        .replace(/^(?: *\/\/.*\n)*.+?setData.+\n/m, '')
        .replace(/^ *(?=data *=[^=])/m, '$&var ')
    });
  });

  return source;
}

/**
 * Removes the `funcName` function declaration, expression, or assignment and
 * associated code from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to remove.
 * @returns {string} Returns the modified source.
 */
function removeFunction(source, funcName) {
  var snippet;

  // defer to specialized removal functions
  if (funcName == 'runInContext') {
    return removeRunInContext(source, funcName);
  }
  // remove function
  if ((snippet = matchFunction(source, funcName, true))) {
    source = source.replace(snippet, '');
  }
  return source;
}

/**
 * Removes all references to `getIndexOf` from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeGetIndexOf(source) {
  source = removeFunction(source, 'getIndexOf');

  _.each(['baseDifference', 'baseUniq', 'contains', 'intersection'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match
        // replace all `getIndexOf` calls with `baseIndexOf`
        .replace(/\bgetIndexOf\(\)/g, 'baseIndexOf')
        // simplify `isLarge` assignments
        .replace(/ *&& *indexOf *=== *baseIndexOf\b/g, '')
    });
  });

  return source;
}

/**
 * Removes the copyright/license header from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeHeader(source) {
  return source.replace(getHeader(source), '');
}

/**
 * Removes the `_.isArguments` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArgumentsFork(source) {
  return source.replace(getIsArgumentsFork(source), '');
}

/**
 * Removes the `_.isArray` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsArrayFork(source) {
  return source.replace(getIsArrayFork(source), '');
}

/**
 * Removes the `_.isElement` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsElementFork(source) {
  return source.replace(getIsElementFork(source), '');
}

/**
 * Removes the `_.isFunction` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeIsFunctionFork(source) {
  return source.replace(getIsFunctionFork(source), '');
}

/**
 * Removes the `@license` tag from the copyright header so minifiers and
 * build optimizers may strip them.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeLicenseTag(source) {
  return source.replace(/^ \* @license\n/m, '');
}

/**
 * Removes a method assignment by name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} [methodName] The name of the method assignment to remove.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignment(source, methodName) {
  return source.replace(getMethodAssignments(source), function(match) {
    var reAssignment = RegExp(
      '^( *//.*\\n)* *' +
      'lodash(?:\\.prototype)?\\.' +
      '(?:[$\\w]+ *= *' + methodName + '|' + methodName + ' *= [$\\w]+);' +
      '\\n(\\n)?'
    , 'gm');

    return match.replace(reAssignment, function(match, comment, newline) {
      return (!newline && comment) || newline || '';
    });
  });
}

/**
 * Removes the Lo-Dash method assignments snippet from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeMethodAssignments(source) {
  return source.replace(getMethodAssignments(source), '');
}

/**
 * Removes all `_.mixin` calls from `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeMixinCalls(source) {
  return source.replace(/^(?: *\/\/.*\n)*( *)mixin\((?:.+?|[\s\S]+?\1(?:}.+?)?)\);\n/gm, '');
}

/**
 * Removes the `_.now` fork from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeNowFork(source) {
  return source.replace(getNowFork(source), '');
}

/**
 * Removes a Lo-Dash property, of the given property name, from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} propName The name of the property to remove.
 * @returns {string} Returns the modified source.
 */
function removeProp(source, propName) {
  return source.replace(matchProp(source, propName, true), '');
}

/**
 * Removes all `runInContext` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeRunInContext(source) {
  // remove local timer variables
  source = removeVar(source, 'clearTimeout');
  source = removeVar(source, 'setTimeout');

  // replace `reThis` reference in `support.funcDecomp` assignment
  source = source.replace(/\btest\(runInContext\)/, 'test(function() { return this; })');

  // remove `runInContext` assignment
  source = source.replace(/^(?: *\/\/.*\n)* *lodash\.runInContext *=[\s\S]+?;\n/m, '');

  // remove function scaffolding, leaving most of its content
  source = source.replace(matchFunction(source, 'runInContext', true), function(match) {
    match = replaceIndent(match, 2, 1);
    return match.replace(/^[\s\S]+?function runInContext\b[\s\S]+?context *= *context.+\s+| *return lodash\b[\s\S]+$/g, '');
  });

  // cleanup adjusted source
  return source
    .replace(/\bcontext\b/g, 'root')
    .replace(/^(?: *\/\*[^*]*\*+(?:[^\/][^*]*\*+)*\/\n)? *var Array *=[\s\S]+?;\n/m, '')
    .replace(/(\breturn *|= *)_([;)])/g, '$1lodash$2')
    .replace(/^(?: *\/\/.*\n)* *var _ *= *runInContext\b.+\n+/m, '');
}

/**
 * Removes the `support.spliceObjects` fix from the `Array` function mixins
 * snippet of `source`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @returns {string} Returns the modified source.
 */
function removeSpliceObjectsFix(source) {
  return source.replace(/^(?: *\/\/.*\n)*( *)if *\(!support\.spliceObjects\b[\s\S]+?(?:\{\s*}|\n\1})\n/m, '');
}

/**
 * Removes all strings from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeStrings(source) {
  return source.replace(reStrings, '');
}

/**
 * Removes all `support.argsClass` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportArgsClass(source) {
  source = removeSupportProp(source, 'argsClass');

  // replace `support.argsClass` in the `_.isArguments` fork
  source = source.replace(getIsArgumentsFork(source), function(match) {
    return match.replace(/!support\.argsClass/g, '!isArguments(arguments)');
  });

  // remove `support.argsClass` from `_.isPlainObject`
  _.each(['shimIsPlainObject', 'isPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*\|\|\s*\(!support\.argsClass\b[\s\S]+?\)\)/, '');
    });
  });

  return source;
}

/**
 * Removes all `support.argsObject` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportArgsObject(source) {
  source = removeSupportProp(source, 'argsObject');

  // remove `argsAreObjects` from `baseIsEqual`
  source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
    return match.replace(/^( *)if *\(!support\.argsObject\b[\s\S]+?\n\1}\n/m, '');
  });

  return source;
}

/**
 * Removes all `support.dom` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportDom(source) {
  source = removeSupportProp(source, 'dom');
  source = removeIsElementFork(source);
  return source;
}

/**
 * Removes all `support.enumErrorProps` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumErrorProps(source) {
  return removeSupportProp(source, 'enumErrorProps');
}

/**
 * Removes all `support.enumPrototypes` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportEnumPrototypes(source) {
  source = removeSupportProp(source, 'enumPrototypes');

  // remove `support.enumPrototypes` from `_.keys`
  source = source.replace(matchFunction(source, 'keys'), function(match) {
    return match
      .replace(/\(support\.enumPrototypes[^)]+\)(?:\s*\|\|\s*)?/, '')
      .replace(/\s*if *\(\s*\)[^}]+}/, '');
  });

  return source;
}

/**
 * Removes all `support.nodeClass` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNodeClass(source) {
  source = removeSupportProp(source, 'nodeClass');

  // remove `support.nodeClass` from `baseClone` and `shimIsPlainObject`
  _.each(['baseClone', 'shimIsPlainObject'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/\s*\|\|\s*\(!support\.nodeClass\b[\s\S]+?\)\)/, '');
    });
  });

  // remove `support.nodeClass` from `baseIsEqual`
  source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
    return match.replace(/\s*\|\|\s*\(!support\.nodeClass\b[\s\S]+?\)\)\)/, '');
  });

  // remove `support.nodeClass` from `_.isElement`
  source = source.replace(matchFunction(source, 'isElement'), function(match) {
    return match.replace(/\(support\.nodeClass\s*\?\s*([^:]+?)\s*:[\s\S]+?\)\)/, '$1');
  });

  return source;
}

/**
 * Removes all `support.nonEnumArgs` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumArgs(source) {
  return removeSupportProp(source, 'nonEnumArgs');
}

/**
 * Removes all `support.nonEnumShadows` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumShadows(source) {
  return removeSupportProp(source, 'nonEnumShadows');
}

/**
 * Removes all `support.nonEnumStrings` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportNonEnumStrings(source) {
  source = removeSupportProp(source, 'nonEnumStrings');

  // remove `support.nonEnumStrings` from `shimKeys`
  source = source.replace(matchFunction(source, 'shimKeys'), function(match) {
    return match.replace(/\s*\|\|\s*\(support\.nonEnumStrings\b[\s\S]+?\)\)/, '');
  });

  return source;
}

/**
 * Removes all `support.ownLast` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportOwnLast(source) {
  source = removeSupportProp(source, 'ownLast');

  // remove `support.ownLast` from `shimIsPlainObject`
  source = source.replace(matchFunction(source, 'shimIsPlainObject'), function(match) {
    return match.replace(/^(?: *\/\/.*\n)*( *)if *\(support\.ownLast\b[\s\S]+?\n\1}\n/m, '');
  });

  return source;
}

/**
 * Removes all `support.spliceObjects` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportSpliceObjects(source) {
  source = removeSupportProp(source, 'spliceObjects');
  source = removeSpliceObjectsFix(source);
  return source;
}

/**
 * Removes all `support.unindexedChars` references from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @returns {string} Returns the modified source.
 */
function removeSupportUnindexedChars(source) {
  source = removeSupportProp(source, 'unindexedChars');

  // remove `support.unindexedChars` from `_.at`, `baseEach`, and `baseEachRight`
  _.each(['at', 'baseEach', 'baseEachRight'], function(funcName) {
    source = source.replace(matchFunction(source, funcName), function(match) {
      return match.replace(/^( *)if *\(support\.unindexedChars\b[\s\S]+?\n\1}\n/m, '');
    });
  });

  // remove `support.unindexedChars` from `_.sample`
  source = source.replace(matchFunction(source, 'sample'), function(match) {
    return match.replace(/\s*else if *\(support\.unindexedChars\b[^}]+}/, '');
  });

  // remove `support.unindexedChars` from `_.toArray`
  source = source.replace(matchFunction(source, 'toArray'), function(match) {
    return match.replace(/(return\b).+?support\.unindexedChars[^:]+:\s*/, '$1 ');
  });

  return source;
}

/**
 * Removes a given property from the `support` object in `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to remove.
 * @returns {string} Returns the modified source.
 */
function removeSupportProp(source, propName) {
  return source.replace(matchProp(source, 'support'), function(match) {
    return match.replace(RegExp(
      '\\n+' + multilineComment +
      // match a `try` block
      '(?:( *)try\\b.+\\n)?' +
      // match the `support` property assignment
      ' *support\\.' + propName + ' *=[\\s\\S]+?;' +
      // match `catch` block
      '(?:\\n\\1} *catch\\b[\\s\\S]+?\\n\\1})?'
    , 'm'), '');
  });
}

/**
 * Removes a variable of the given variable name from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the variable to remove.
 * @returns {string} Returns the modified source.
 */
function removeVar(source, varName) {
  // simplify complex variable assignments
  if (_.contains(complexVars, varName)) {
    source = source.replace(RegExp(
      '^( *var ' + varName + ') *=[\\s\\S]+?' +
      '(?:\\(function\\b[\\s\\S]+?\\}\\([^)]*\\)\\);(?=\\n\\n)|' +
      '[;}](?=\\n\\n(?!\\s*\\(func)))'
    , 'm'), '$1 = null;')
  }

  _.some([
    function() {
      return removeFunction(source, varName);
    },
    function() {
      // remove a varaible at the start of a declaration list
      return source.replace(RegExp('(var +)' + varName + ' *=.+?,\\n *'), '$1');
    },
    function() {
      // remove a variable declaration in a declaration list
      return source.replace(RegExp(
        '( *(?:var +)?[$\\w]+ *=.+?),\\n *' + varName + ' *=.+?([,;])(?=\\n)'
      ), '$1$2');
    },
    function() {
      // remove a variable that is not part of a declaration list
      return source.replace(RegExp(
        '^' + multilineComment +
        '( *)var ' + varName + ' *(?:|= *(?:.+?(?:&&\\n[\\s\\S]+?)?|(?:[($\\w]+\\(|[{[(]\\n)[\\s\\S]+?\\n\\1[^\\n ]+?));\\n'
      , 'm'), '');
    }
  ], function(func) {
    var result = func();
    if (result !== source) {
      source = result;
      return true;
    }
  });

  return source;
}

/**
 * Replaces the `funcName` function body in `source` with `funcValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} funcName The name of the function to replace.
 * @param {string} funcValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceFunction(source, funcName, funcValue) {
  var checkFuncTag = /^\s*var\s+/.test(funcValue),
      snippet = matchFunction(source, funcName, checkFuncTag);

  if (!snippet) {
    return source;
  }
  return source.replace(snippet, function(match) {
    var header = checkFuncTag ? getHeader(match) : '';
    if (header && !isFunctionSnippet(snippet)) {
      header = header.replace(/^( *)\* *(?:@(?:category|param|returns)\b|\/)/m, function(match, indent) {
        return indent + '* @type Function\n' + match;
      });
    }
    return header + funcValue
      .replace(RegExp('^' + getIndent(funcValue), 'gm'), getIndent(snippet))
      .trimRight() + '\n';
  });
}

/**
 * Replaces the IIFE that wraps `source` with `iife`. If the `%output%` token
 * is present in `iife` it will be replaced with the unwrapped `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} iife The replacement IIFE.
 * @returns {string} Returns the modified source.
 */
function replaceIIFE(source, iife) {
  var token = '%output%',
      header = getHeader(source),
      index = iife.indexOf(token);

  if (index < 0) {
    return header + iife;
  }
  return header +
    iife.slice(0, index) +
    source.replace(/^[\s\S]+?\(function[^{]+\{\n+|\s*}\.call\(this\)\)[;\s]*$/g, '\n') +
    iife.slice(index + token.length);
}

/**
 * Replaces the indent at level `from` of the given source with the level `to`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} from The indent level to be replaced.
 * @param {number} to The indent level to replace with.
 * @returns {string} Returns the modified source.
 */
function replaceIndent(source, from, to) {
  return source.replace(RegExp('^(?:  ){' + (from || 1) + '}', 'gm'), _.repeat('  ', to));
}

/**
 * Replaces the `support` object `propName` property value in `source` with `propValue`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {string} varName The name of the `support` property to replace.
 * @returns {string} Returns the modified source.
 */
function replaceSupportProp(source, propName, propValue) {
  return source.replace(RegExp(
    // match a `try` block
    '(?: *try\\b.+\\n)?' +
    // match the `support` property assignment
    '( *support\\.' + propName + ' *=).+\\n' +
    // match `catch` block
    '(?:( *).+?catch\\b[\\s\\S]+?\\n\\2}\\n)?'
  ), function(match, left) {
    return left + ' ' + propValue + ';\n';
  });
}

/**
 * Replaces the `varName` variable declaration value in `source` with `varValue`.
 *
 * @private
 * @param {string} source The source to inspect.
 * @param {string} varName The name of the variable to replace.
 * @param {string} varValue The replacement value.
 * @returns {string} Returns the modified source.
 */
function replaceVar(source, varName, varValue) {
  // replace a variable that's not part of a declaration list
  var result = source.replace(RegExp(
    '(( *)var ' + varName + ' *=)' +
    '(?:.+?;|(?:Function\\(.+?|.*?[^,])\\n[\\s\\S]+?\\n\\2.+?;)\\n'
  ), function(match, left) {
    return left + ' ' + varValue + ';\n';
  });

  if (source == result) {
    // replace a varaible at the start or middle of a declaration list
    result = source.replace(RegExp('((?:var|\\n) +' + varName + ' *=).+?,'), function(match, left) {
      return left + ' ' + varValue + ',';
    });
  }
  if (source == result) {
    // replace a variable at the end of a variable declaration list
    result = source.replace(RegExp('(,\\s*' + varName + ' *=).+?;'), function(match, left) {
      return left + ' ' + varValue + ';';
    });
  }
  return result;
}

/**
 * Add or remove the "use strict" directive from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {boolean} value The value to set.
 * @returns {string} Returns the modified source.
 */
function setUseStrictOption(source, value) {
  return source.replace(/^([\s\S]*?function[^{]+\{)(?:\s*'use strict';)?/, '$1' + (value ? "\n  'use strict';" : ''));
}

/**
 * This function allows `callback` to modify `source` with string literals
 * removed and returns the modified source with string literals restored.
 *
 * @private
 * @param {string} source The source to modify.
 * @param {Function} [callback] The function to modify the string free source.
 * @returns {string} Returns the modified source.
 */
function stringFree(source, callback) {
  var strings = [];

  source = callback(source.replace(reStrings, function(match) {
    strings.push(match);
    return stringToken;
  })) || '';

  source = source.replace(reStringTokens, function() {
    return strings.shift();
  });

  return source;
}

/**
 * Trims the indent of the specified level from `source`.
 *
 * @private
 * @param {string} source The source to process.
 * @param {number} level The level of indent to trim.
 * @returns {string} Returns the modified source.
 */
function trimIndent(source, level) {
  return replaceIndent(source, level || 1);
}

/*----------------------------------------------------------------------------*/

/**
 * Creates a debug and/or minified build, executing the callback for each.
 * The callback is invoked with one argument; (data).
 *
 * Note: For a list of commands see `displayHelp()` or run `lodash --help`.
 *
 * @param {Array|Object} [options=[]] An array of build commands or the state object.
 * @param {Function} [callback=defaultBuildCallback] The function called per build.
 */
function build(options, callback) {
  options || (options = []);

  // the debug version of `source`
  var debugSource;

  // used to specify the output path for builds
  var outputPath;

  // used to specify the source map URL
  var sourceMapURL;

  // use to pre-populate the build state
  var state = _.isPlainObject(options) && options;

  var isExcluded = function() {
    return _.every(arguments, _.negate(_.partial(_.contains, buildFuncs, _, 0)));
  };

  var isLodash = function(funcName) {
    funcName = getRealName(funcName);
    if (_.contains(lodashOnlyFuncs, funcName) || /^(?:assign|zipObject)$/.test(funcName)) {
      var funcNames = _.difference(_.union(includeFuncs, plusFuncs), minusFuncs);
      return _.contains(funcNames, funcName);
    }
    funcNames = _.difference(plusFuncs, minusFuncs);
    return _.contains(funcNames, funcName);
  };

  if (state) {
    var buildFuncs = state.buildFuncs,
        filePath = state.filePath,
        funcDepMap = state.funcDepMap,
        includeFuncs = state.includeFuncs,
        includeObjs = state.includeObjs,
        includeVars = state.includeVars,
        isDebug = true,
        isModularize = true,
        isStdOut = state.isStdOut,
        isStrict = state.isStrict,
        minusFuncs = [],
        objDepMap = state.objDepMap,
        outputPath = state.outputPath,
        plusFuncs = [],
        source = state.source,
        varDepMap = state.varDepMap;
  }
  else {
    // clone dependencies to modify
    var funcDepMap = createMap(_.cloneDeep(funcDependencyMap)),
        objDepMap = createMap(_.cloneDeep(objDependencyMap)),
        varDepMap = createMap(_.cloneDeep(varDependencyMap));

    // the path to the source file
    var filePath = require.resolve('lodash/lodash.js');

    // used to specify a custom IIFE to wrap Lo-Dash
    var iife = getOption(options, 'iife');

    // used to match external template files to precompile
    var templatePattern = getOption(options, 'template', '');

    // used as the template settings for precompiled templates
    var templateSettings = (function() {
      var result = getOption(options, 'settings');
      return result
        ? Function('return {' + result.replace(/^\{|}$/g, '') + '}')()
        : _.clone(_.templateSettings);
    }());

    // flag to specify a Backbone build
    var isBackbone = getOption(options, 'backbone');

    // flag to specify only creating the debug build
    var isDebug = getOption(options, '-d') || getOption(options, '--debug');

    // flag to indicate that a custom IIFE was specified
    var isIIFE = typeof iife == 'string';

    // flag to specify creating a source map for the minified source
    var isMapped = getOption(options, '-p') || getOption(options, '--source-map');

    // flag to specify only creating the minified build
    var isMinify = getOption(options, '-m') || getOption(options, '--minify');

    // flag to specify a modern build
    var isModern = getOption(options, 'csp') || getOption(options, 'CSP') || getOption(options, 'modern');

    // flag to specify a modularize build
    var isModularize = getOption(options, 'modularize');

    // flag to specify writing output to standard output
    var isStdOut = getOption(options, '-c') || getOption(options, '--stdout');

    // flag to specify skipping status updates normally logged to the console
    var isSilent = isStdOut || getOption(options, '-s') || getOption(options, '--silent');

    // flag to specify `_.assign`, `_.bindAll`, and `_.defaults`
    // are constructed using the "use strict" directive
    var isStrict = getOption(options, 'strict');

    // flag to specify a template build
    var isTemplate = !!templatePattern;

    // flag to specify an Underscore build
    var isUnderscore = isBackbone || getOption(options, 'underscore');

    // used to specify the ways to export the `lodash` function
    var exportsOptions = (function() {
      var result = getOption(options, 'exports', isModularize ? ['amd'] : defaultExports);
      return isModularize ? _.first(result, 1) : result;
    }());

    // used to specify the AMD module ID of Lo-Dash used by precompiled templates
    var moduleId = getOption(options, 'moduleId', isUnderscore ? 'underscore' : null);

    // used as the output path for the build
    var outputPath = _.reduce(options, function(result, value, index) {
      return /^(?:-o|--output)$/.test(value)
        ? path.normalize(options[index + 1])
        : result;
    }, isModularize ? '.' + path.sep + 'modularize' : '');

    // flag to specify creating a custom build
    var isCustom = !isModularize && (
      isMapped || isModern || isStrict || isTemplate || isUnderscore || outputPath ||
      getOption(options, 'compat') || getOption(options, 'legacy') || getOption(options, 'mobile') ||
      /\b(?:category|exclude|exports|iife|include|minus|moduleId|plus)=/.test(options) ||
      !_.isEqual(exportsOptions, defaultExports)
    );

    // flags to specify export options
    var isAMD = _.contains(exportsOptions, 'amd'),
        isCommonJS = _.contains(exportsOptions, 'commonjs'),
        isES6 = _.contains(exportsOptions, 'es6'),
        isGlobal = _.contains(exportsOptions, 'global'),
        isNpm = _.contains(exportsOptions, 'npm'),
        isNode = isNpm || _.contains(exportsOptions, 'node');

    // the lodash.js source
    var source = fs.readFileSync(filePath, 'utf8');

    /*------------------------------------------------------------------------*/

    // categories of functions to include in the build
    var categoryOptions = _.map(getOption(options, 'category', []), _.compose(_.capitalize, _.partial(_.result, _, 'toLowerCase')));

    // functions to include in the build
    var includeFuncs = categoryOptions.concat(_.map(getOption(options, 'include', []), _.partial(getRealName, _, funcDepMap)));

    // properties to include in the build
    var includeObjs = _.intersection(includeFuncs, objDependencies);

    // variables to include in the build
    var includeVars = _.intersection(includeFuncs, varDependencies);

    // functions to remove from the build
    var minusFuncs = _.map(_.union(getOption(options, 'exclude', []), getOption(options, 'minus', [])), _.partial(getRealName, _, funcDepMap));

    // functions to add to the build
    var plusFuncs = _.map(getOption(options, 'plus', []), _.partial(getRealName, _, funcDepMap));

    // expand categories to function names
    _.each([includeFuncs, minusFuncs, plusFuncs], function(funcNames) {
      var categories = _.intersection(funcNames, allCategories);

      _.each(categories, function(category) {
        var otherFuncs = _.filter(getNamesByCategory(category), function(key) {
          var type = typeof _[key];
          return type == 'function' || type == 'undefined';
        });

        // limit function names to those available for specific builds
        if (isBackbone) {
          otherFuncs = _.intersection(otherFuncs, backboneDependencies);
        } else if (isUnderscore) {
          otherFuncs = _.intersection(otherFuncs, underscoreFuncs);
        }
        push.apply(funcNames, otherFuncs);
      });
    });

    // remove categories from function names
    includeFuncs = _.difference(includeFuncs, allCategories, includeObjs, includeVars);
    minusFuncs = _.difference(minusFuncs, allCategories);
    plusFuncs = _.difference(plusFuncs, allCategories);

    /*------------------------------------------------------------------------*/

    // used to capture warnings for invalid command-line arguments
    var warnings = [];

    // used to detect invalid command-line arguments
    var invalidArgs = _.reject(options.slice(reNode.test(options[0]) ? 2 : 0), function(value, index, options) {
      if (/^(?:-o|--output)$/.test(options[index - 1]) ||
          /^(?:category|exclude|exports|iife|include|moduleId|minus|plus|settings|template)=[\s\S]*$/.test(value)) {
        return true;
      }
      var result = _.contains([
        'backbone',
        'compat', 'legacy', 'mobile',
        'modern', 'csp',
        'modularize',
        'strict',
        'underscore',
        '-c', '--stdout',
        '-d', '--debug',
        '-h', '--help',
        '-m', '--minify',
        '-o', '--output',
        '-p', '--source-map',
        '-s', '--silent',
        '-V', '--version'
      ], value);

      if (!result && /^(?:-p|--source-map)$/.test(options[index - 1])) {
        sourceMapURL = value;
        return true;
      }
      return result;
    });

    // report invalid command and option arguments
    if (!_.isEmpty(invalidArgs)) {
      warnings.push('Invalid argument' + (_.size(invalidArgs) > 1 ? 's' : '') + ' passed: ' + invalidArgs.join(', '));
    }
    // report invalid command combinations
    invalidArgs = _.intersection(options, ['backbone', 'compat', 'csp', 'legacy', 'mobile', 'modern', 'underscore']);

    if (isTemplate) {
      invalidArgs.push('template');
    }
    if (_.size(invalidArgs) > 1) {
      warnings.push('The `' + invalidArgs.slice(0, -1).join('`, `') + '`' + (_.size(invalidArgs) > 2 ? ',' : '') + ' and `' + invalidArgs.slice(-1) + '` commands may not be combined.');
    }
    // report invalid command entries
    _.forOwn({
      'category': {
        'entries': categoryOptions,
        'validEntries': allCategories
      },
      'exports': {
        'entries': exportsOptions,
        'validEntries': isModularize ? ['amd', 'commonjs', 'es6', 'node', 'npm'] : defaultExports
      },
      'include': {
        'entries': includeFuncs,
        'validEntries': allFuncs
      },
      'minus': {
        'entries': minusFuncs,
        'validEntries': allFuncs
      },
      'plus': {
        'entries': plusFuncs,
        'validEntries': allFuncs
      }
    }, function(data, commandName) {
      invalidArgs = _.difference(data.entries, data.validEntries, ['none']);
      if (!_.isEmpty(invalidArgs)) {
        warnings.push('Invalid `' + commandName + '` entr' + (_.size(invalidArgs) > 1 ? 'ies' : 'y') + ' passed: ' + invalidArgs.join(', '));
      }
    });

    if (!_.isEmpty(warnings)) {
      console.warn([''].concat(
        warnings,
        'For more information type: lodash --help'
      ).join('\n'));
      return;
    }
    // display help message
    if (getOption(options, '-h') || getOption(options, '--help')) {
      displayHelp();
      return;
    }
    // display `lodash.VERSION`
    if (getOption(options, '-V') || getOption(options, '--version')) {
      console.log(_.VERSION);
      return;
    }

    /*------------------------------------------------------------------------*/

    // names of functions to include in the build
    var buildFuncs = !isTemplate && (function() {
      var result;

      source = setUseStrictOption(source, isStrict);

      if (isModularize) {
        if (!isCommonJS) {
          _.forOwn(varDepMap, function(depNames) {
            _.pull(depNames, 'root');
          });
          delete varDepMap.root;
        }
        funcDepMap.lodash.push('arrayEach', 'assign', 'mixin');
        objDepMap.lodash = ['support'];

        if (!isUnderscore) {
          funcDepMap.lodash.push('baseForOwn');
        }
        _.pull(funcDepMap.mixin, 'lodash');

        // remove `_` placeholder support
        _.each(['baseCreateWrapper', 'createWrapper'], function(funcName) {
          _.pull(funcDepMap[funcName], 'getHolders');

          source = source.replace(matchFunction(source, funcName), function(match) {
            return match.replace(/\bgetHolders\([^)]+\)/g, '[]');
          });
        });
      }
      else {
        funcDepMap.chain.push('wrapperChain');
        funcDepMap.wrapperValueOf.push('arrayEach', 'assign', 'mixin', 'wrapperChain');
        objDepMap.wrapperValueOf = ['support'];

        _.each(['chain', 'lodashWrapper', 'tap', 'wrapperChain'], function(funcName) {
          funcDepMap[funcName].push('wrapperValueOf');
        });

        if (!isUnderscore || isLodash('chain')) {
          funcDepMap.wrapperToString.push('wrapperValueOf');
          funcDepMap.wrapperValueOf.push('baseForOwn', 'wrapperToString');
        }
      }
      if (isModern) {
        source = removeIsFunctionFork(source);
        source = removeIsArgumentsFork(source);
        source = removeSupportSpliceObjects(source);
      }
      if (_.contains(plusFuncs, 'chain') == !isUnderscore) {
        source = addUnderscoreChaining(source, isModularize);
        _.pull(funcDepMap.mixin, 'isObject');

        if (!isModularize) {
          _.pull(funcDepMap.mixin, 'isFunction');
        }
      }
      if (isModern || (isUnderscore && _.isEmpty(plusFuncs))) {
        source = removeSupportArgsClass(source);
        source = removeSupportArgsObject(source);
        source = removeSupportEnumErrorProps(source);
        source = removeSupportEnumPrototypes(source);
        source = removeSupportNonEnumShadows(source);
        source = removeSupportNonEnumStrings(source);
        source = removeSupportOwnLast(source);

        _.each([
          'at', 'baseClone', 'baseEach', 'baseEachRight', 'baseIsEqual',
          'isArguments', 'isPlainObject', 'sample','shimIsPlainObject', 'toArray'
        ], function(funcName) {
          if (!(isUnderscore && isLodash(funcName))) {
            _.pull(objDepMap[funcName], 'support');
          }
        });

        source = removeSupportNodeClass(source);
        _.each(['baseClone', 'baseIsEqual', 'isElement', 'shimIsPlainObject'], function(funcName) {
          if (!(isUnderscore && isLodash(funcName))) {
            _.pull(funcDepMap[funcName], 'isNode');
          }
        });

        source = removeSupportUnindexedChars(source);
        _.each(['at', 'baseEach', 'baseEachRight', 'sample', 'shimKeys', 'toArray'], function(funcName) {
          if (!(isUnderscore && isLodash(funcName))) {
            _.pull(funcDepMap[funcName], 'isString');
          }
        });
      }
      if (isModern || isUnderscore) {
        // replace `_.find`
        if (!(isUnderscore && isLodash('find'))) {
          _.pull(funcDepMap.find, 'isArray');

          source = replaceFunction(source, 'find', [
            'function find(collection, predicate, thisArg) {',
            '  var length = collection ? collection.length : 0;',
            '',
            "  if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {",
            '    var index = findIndex(collection, predicate, thisArg);',
            '    return index > -1 ? collection[index] : undefined;',
            '  }',
            '  predicate = lodash.createCallback(predicate, thisArg, 3);',
            '  return baseFind(collection, predicate, baseEach);',
            '}',
          ].join('\n'));
        }
        // replace `_.forEach`
        if (!(isUnderscore && isLodash('forEach'))) {
          _.pull(funcDepMap.forEach, 'isArray');

          source = replaceFunction(source, 'forEach', [
            'function forEach(collection, callback, thisArg) {',
            '  var length = collection ? collection.length : 0;',
            "  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);",
            '',
            "  return (typeof length == 'number' && length > -1 && length <= maxSafeInteger)",
            '    ? arrayEach(collection, callback)',
            '    : baseEach(collection, callback);',
            '}',
          ].join('\n'));
        }
        // replace `_.forEachRight`
        if (!(isUnderscore && isLodash('forEachRight'))) {
          _.pull(funcDepMap.forEachRight, 'isArray');

          source = replaceFunction(source, 'forEachRight', [
            'function forEachRight(collection, callback, thisArg) {',
            '  var length = collection ? collection.length : 0;',
            "  callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);",
            '',
            "  return (typeof length == 'number' && length > -1 && length <= maxSafeInteger)",
            '    ? arrayEachRight(collection, callback)',
            '    : baseEachRight(collection, callback);',
            '}',
          ].join('\n'));
        }
        // replace `_.isRegExp`
        if (!isUnderscore) {
          _.pull(funcDepMap.isRegExp, 'isObject');

          source = replaceFunction(source, 'isRegExp', [
            'function isRegExp(value) {',
            "  return (value && typeof value == 'object' && toString.call(value) == regexpClass) || false;",
            '}'
          ].join('\n'));
        }
        // replace `_.keysIn`
        if (!(isUnderscore && isLodash('keysIn'))) {
          _.pull(funcDepMap.keysIn, 'isString');

          source = replaceFunction(source, 'keysIn', [
            'function keysIn(object) {',
            '  if (!isObject(object)) {',
            '    return [];',
            '  }',
            '  var length = object.length;',
            "  length = (typeof length == 'number' && length > 0 &&",
            '    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) >>> 0;',
            '',
            '  var keyIndex,',
            '      ctor = object.constructor,',
            '      index = -1,',
            '      isProto = ctor && object === ctor.prototype,',
            '      maxIndex = length - 1,',
            '      result = Array(length),',
            '      skipIndexes = length > 0;',
            '',
            '  while (++index < length) {',
            '    result[index] = String(index);',
            '  }',
            '  for (var key in object) {',
            "    if (!(isProto && key == 'constructor') &&",
            '        !(skipIndexes && (keyIndex = +key, keyIndex > -1 && keyIndex <= maxIndex && keyIndex % 1 == 0))) {',
            '      result.push(key);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.map`
        if (!(isUnderscore && (isLodash('map') || isLodash('pluck')))) {
          _.pull(funcDepMap.map, 'isArray');

          source = replaceFunction(source, 'map', [
            'function map(collection, callback, thisArg) {',
            '  var length = collection ? collection.length : 0;',
            '  callback = lodash.createCallback(callback, thisArg, 3);',
            '',
            "  if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {",
            '    return arrayMap(collection, callback);',
            '  }',
            '  var index = -1,',
            '      result = [];',
            '',
            '  baseEach(collection, function(value, key, collection) {',
            '    result[++index] = callback(value, key, collection);',
            '  });',
            '  return result;',
            '}'
          ].join('\n'));
        }

        _.each(['baseIsEqual', 'isPlainObject', 'shimIsPlainObject'], function(funcName) {
          if (!(isUnderscore && isLodash(funcName))) {
            _.pull(funcDepMap[funcName], 'isArguments');
          }
        });

        _.each(['createAggregator', 'every', 'filter', 'reduce', 'some'], function(funcName) {
          if (!(isUnderscore && isLodash(funcName))) {
            _.pull(funcDepMap[funcName], 'isArray');
          }
        });

        _.each(['createAggregator', 'every', 'filter', 'max', 'min', 'reduce', 'some'], function(funcName) {
          if (!(isUnderscore && isLodash(funcName))) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              if (!isUnderscore && (funcName == 'min' || funcName == 'max')) {
                return match;
              }
              // replace `_.isArray` checks with array-like checks
              match = match.replace(/^( *)(if *\(.*?\bisArray\([^\)]+\).*?\) *\{\n)( *var index\b[^;]+;\n+)?/m, function(snippet, indent, statement, vars) {
                if (vars) {
                  vars = vars
                    .replace(/\b(length *=)[^;=]+/, '$1 collection ? collection.length : 0')
                    .replace(RegExp('^  ' + indent, 'gm'), indent);
                }
                return (vars || '') + indent +
                  statement.replace(/\bisArray\([^\)]+\)/, "typeof length == 'number' && length > -1 && length <= maxSafeInteger");
              });

              // adjust `callback` assignment placement
              return match.replace(/\n+ *callback *=[^;]+;(?=\n *var )/, '$&\n');
            });
          }
        });
      }
      if (isUnderscore) {
        source = removeSupportNonEnumArgs(source);

        // replace `lodash`
        if (!isLodash('lodash')) {
          _.pull(funcDepMap.lodash, 'isArray');

          source = replaceFunction(source, 'lodash', [
            'function lodash(value) {',
            '  return (value instanceof lodash)',
            '    ? value',
            '    : new lodashWrapper(value);',
            '}'
          ].join('\n'));
        }
        // replace `_.assign`
        if (!isLodash('assign')) {
          _.pull(funcDepMap.assign, 'baseCreateCallback', 'keys');

          source = replaceFunction(source, 'assign', [
            'function assign(object, source, guard) {',
            '  if (!object) {',
            '    return object;',
            '  }',
            '  var args = arguments,',
            '      argsIndex = 0,',
            '      argsLength = args.length,',
            '      type = typeof guard;',
            '',
            "  if ((type == 'number' || type == 'string') && args[3] && args[3][guard] === source) {",
            '    argsLength = 2;',
            '  }',
            '  while (++argsIndex < argsLength) {',
            '    source = args[argsIndex];',
            '    for (var key in source) {',
            '      object[key] = source[key];',
            '    }',
            '  }',
            '  return object;',
            '}'
          ].join('\n'));
        }
        // replace `_.bind`
        if (!isLodash('bind')) {
          source = replaceFunction(source, 'bind', [
            'function bind(func, thisArg) {',
            '  return arguments.length < 3',
            '    ? createWrapper(func, BIND_FLAG, null, thisArg)',
            '    : createWrapper(func, BIND_FLAG | PARTIAL_FLAG, null, thisArg, slice(arguments, 2));',
            '}'
          ].join('\n'));
        }
        // replace `_.clone`
        if (!isLodash('baseClone') && !isLodash('clone') && !isLodash('cloneDeep')) {
          _.pull(funcDepMap.clone, 'baseClone', 'baseCreateCallback').push('assign', 'isArray', 'isObject', 'slice');

          source = replaceFunction(source, 'clone', [
            'function clone(value) {',
            '  return isObject(value)',
            '    ? (isArray(value) ? slice(value) : assign({}, value))',
            '    : value;',
            '}'
          ].join('\n'));
        }
        // replace `_.contains`
        if (!isLodash('contains')) {
          _.pull(funcDepMap.contains, 'isArray', 'isNative', 'isString');

          source = replaceFunction(source, 'contains', [
            'function contains(collection, target) {',
            '  var indexOf = getIndexOf(),',
            '      length = collection ? collection.length : 0;',
            '',
            "  if (!(typeof length == 'number' && length > -1 && length <= maxSafeInteger)) {",
            '    collection = values(collection);',
            '  }',
            '  return indexOf(collection, target) > -1;',
            '}'
          ].join('\n'));
        }
        // replace `_.defaults`
        if (!isLodash('defaults')) {
          _.pull(funcDepMap.defaults, 'assign', 'assignDefaults', 'slice');

          source = replaceFunction(source, 'defaults', [
            'function defaults(object, source, guard) {',
            '  if (!object) {',
            '    return object;',
            '  }',
            '  var args = arguments,',
            '      argsIndex = 0,',
            '      argsLength = args.length,',
            '      type = typeof guard;',
            '',
            "  if ((type == 'number' || type == 'string') && args[3] && args[3][guard] === source) {",
            '    argsLength = 2;',
            '  }',
            '  while (++argsIndex < argsLength) {',
            '    source = args[argsIndex];',
            '    for (var key in source) {',
            "      if (typeof object[key] == 'undefined') {",
            '        object[key] = source[key];',
            '      }',
            '    }',
            '  }',
            '  return object;',
            '}'
          ].join('\n'));
        }
        // replace `baseDifference`
        if (!(isUnderscore && (isLodash('baseDifference') || isLodash('difference')))) {
          _.pull(funcDepMap.baseDifference, 'cacheIndexOf', 'createCache');

          source = replaceFunction(source, 'baseDifference', [
            'function baseDifference(array, values) {',
            '  var length = array ? array.length : 0;',
            '  if (!length) {',
            '    return [];',
            '  }',
            '  var index = -1,',
            '      indexOf = getIndexOf(),',
            '      result = [];',
            '',
            '  while (++index < length) {',
            '    var value = array[index];',
            '    if (indexOf(values, value) < 0) {',
            '      result.push(value);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.first`
        if (!isLodash('first')) {
          _.pull(funcDepMap.first, 'createCallback');

          source = replaceFunction(source, 'first', [
            'function first(array, n, guard) {',
            '  if (n == null || guard) {',
            '    return array ? array[0] : undefined;',
            '  }',
            '  return slice(array, 0, n < 0 ? 0 : n);',
            '}'
            ].join('\n'));
        }
        // replace `_.flatten`
        if (!isLodash('flatten')) {
          _.pull(funcDepMap.flatten, 'map');

          source = replaceFunction(source, 'flatten', [
            'function flatten(array, isShallow, guard) {',
            '  var length = array ? array.length : 0;',
            '  if (!length) {',
            '    return [];',
            '  }',
            '  var type = typeof isShallow;',
            "  if ((type == 'number' || type == 'string') && guard && guard[isShallow] === array) {",
            '    isShallow = false;',
            '  }',
            '  return baseFlatten(array, isShallow);',
            '}'
          ].join('\n'));
        }
        // replace `_.initial`
        if (!isLodash('initial')) {
          _.pull(funcDepMap.initial, 'createCallback');

          source = replaceFunction(source, 'initial', [
            'function initial(array, n, guard) {',
            '  var length = array ? array.length : 0;',
            '  if (n == null || guard) {',
            '    n = 1;',
            '  }',
            '  n = length - (n || 0);',
            '  return slice(array, 0, n < 0 ? 0 : n);',
            '}'
          ].join('\n'));
        }
        // replace `_.intersection`
        if (!(isUnderscore && isLodash('intersection'))) {
          _.pull(funcDepMap.intersection, 'cacheIndexOf', 'createCache');

          source = replaceFunction(source, 'intersection', [
            'function intersection() {',
            '  var args = [],',
            '      argsIndex = -1,',
            '      argsLength = arguments.length;',
            '',
            '  while (++argsIndex < argsLength) {',
            '    var value = arguments[argsIndex];',
            '     if (isArray(value) || isArguments(value)) {',
            '       args.push(value);',
            '     }',
            '  }',
            '  argsLength = args.length;',
            '  var array = args[0],',
            '      index = -1,',
            '      indexOf = getIndexOf(),',
            '      length = array ? array.length : 0,',
            '      result = [];',
            '',
            '  outer:',
            '  while (++index < length) {',
            '    value = array[index];',
            '    if (indexOf(result, value) < 0) {',
            '      var argsIndex = argsLength;',
            '      while (--argsIndex) {',
            '        if (indexOf(args[argsIndex], value) < 0) {',
            '          continue outer;',
            '        }',
            '      }',
            '      result.push(value);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.invert`
        if (!isLodash('invert')) {
          source = replaceFunction(source, 'invert', [
            'function invert(object) {',
            '  var index = -1,',
            '      props = keys(object),',
            '      length = props.length,',
            '      result = {};',
            '',
            '  while (++index < length) {',
            '    var key = props[index];',
            '    result[object[key]] = key;',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.isElement`
        if (!isLodash('isElement')) {
          funcDepMap.isElement = [];
          _.pull(objDepMap.isElement, 'support');

          source = removeSupportDom(source);

          source = replaceFunction(source, 'isElement', [
            'function isElement(value) {',
            '  return (value && value.nodeType === 1) || false;',
            '}'
          ].join('\n'));
        }
        // replace `_.isEmpty`
        if (!isLodash('isEmpty')) {
          _.pull(funcDepMap.isEmpty, 'baseForOwn', 'isFunction');

          source = replaceFunction(source, 'isEmpty', [
            'function isEmpty(value) {',
            '  if (!value) {',
            '    return true;',
            '  }',
            '  var length = value.length;',
            '  if ((length > -1 && length <= maxSafeInteger) &&',
            '      (isArray(value) || isString(value) || isArguments(value))) {',
            '    return !length;',
            '  }',
            '  for (var key in value) {',
            '    if (hasOwnProperty.call(value, key)) {',
            '      return false;',
            '    }',
            '  }',
            '  return true;',
            '}'
          ].join('\n'));
        }
        // replace `_.isEqual`
        if (!isLodash('baseIsEqual') && !isLodash('isEqual')) {
          _.pull(funcDepMap.baseIsEqual, 'isArguments', 'isNode');
          _.pull(objDepMap.baseIsEqual, 'support');

          source = replaceFunction(source, 'isEqual', [
            'function isEqual(value, other) {',
            '  return baseIsEqual(value, other);',
            '}'
          ].join('\n'));

          source = replaceFunction(source, 'baseIsEqual', [
            'function baseIsEqual(value, other, stackA, stackB) {',
            '  if (value === other) {',
            '    return value !== 0 || (1 / value == 1 / other);',
            '  }',
            '  var valType = typeof value,',
            '      othType = typeof other;',
            '',
            '  if (value === value && (value == null || other == null ||',
            "      (valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object'))) {",
            '    return false;',
            '  }',
            '  var valClass = toString.call(value),',
            '      othClass = toString.call(other);',
            '',
            '  if (valClass != othClass) {',
            '    return false;',
            '  }',
            '  switch (valClass) {',
            '    case boolClass:',
            '    case dateClass:',
            '      return +value == +other;',
            '',
            '    case numberClass:',
            '      return value != +value',
            '        ? other != +other',
            '        : (value == 0 ? (1 / value == 1 / other) : value == +other);',
            '',
            '    case regexpClass:',
            '    case stringClass:',
            '      return value == String(other);',
            '  }',
            '  var isArr = valClass == arrayClass;',
            '  if (!isArr) {',
            '    if (valClass != objectClass) {',
            '      return false;',
            '    }',
            "    var valWrapped = hasOwnProperty.call(value, '__wrapped__'),",
            "        othWrapped = hasOwnProperty.call(other, '__wrapped__');",
            '',
            '    if (valWrapped || othWrapped) {',
            '      return baseIsEqual(valWrapped ? value.__wrapped__ : value, othWrapped ? other.__wrapped__ : other, stackA, stackB);',
            '    }',
            "    var hasValCtor = hasOwnProperty.call(value, 'constructor'),",
            "        hasOthCtor = hasOwnProperty.call(other, 'constructor');",
            '',
            '    if (hasValCtor != hasOthCtor) {',
            '      return false;',
            '    }',
            '    if (!hasValCtor) {',
            '      var valCtor = value.constructor,',
            '          othCtor = other.constructor;',
            '',
            '      if (valCtor != othCtor &&',
            '            !(isFunction(valCtor) && valCtor instanceof valCtor && isFunction(othCtor) && othCtor instanceof othCtor) &&',
            "            ('constructor' in value && 'constructor' in other)",
            '          ) {',
            '        return false;',
            '      }',
            '    }',
            '  }',
            '  stackA || (stackA = []);',
            '  stackB || (stackB = []);',
            '',
            '  var length = stackA.length;',
            '  while (length--) {',
            '    if (stackA[length] == value) {',
            '      return stackB[length] == other;',
            '    }',
            '  }',
            '  var result = true,',
            '      size = 0;',
            '',
            '  stackA.push(value);',
            '  stackB.push(other);',
            '',
            '  if (isArr) {',
            '    size = other.length;',
            '    result = size == value.length;',
            '',
            '    if (result) {',
            '      while (size--) {',
            '        if (!(result = baseIsEqual(value[size], other[size], stackA, stackB))) {',
            '          break;',
            '        }',
            '      }',
            '    }',
            '  }',
            '  else {',
            '    baseForIn(other, function(othValue, key, other) {',
            '      if (hasOwnProperty.call(other, key)) {',
            '        size++;',
            '        return (result = hasOwnProperty.call(value, key) && baseIsEqual(value[key], othValue, stackA, stackB));',
            '      }',
            '    });',
            '',
            '    if (result) {',
            '      baseForIn(value, function(valValue, key, value) {',
            '        if (hasOwnProperty.call(value, key)) {',
            '          return (result = --size > -1);',
            '        }',
            '      });',
            '    }',
            '  }',
            '  stackA.pop();',
            '  stackB.pop();',
            '  return result;',
            '}'
          ].join('\n'));

           // replace complex lodash wrapper checks with simpler ones
          if (!isModularize) {
            source = source.replace(matchFunction(source, 'baseIsEqual'), function(match) {
              return match.replace(/hasOwnProperty\.call\(([$\w]+), *'__wrapped__'\)/g, '$1 instanceof lodash')
            });
          }
        }
        // replace `_.keys` and `shimKeys`
        if (!isLodash('keys')) {
          _.pull(funcDepMap.shimKeys, 'isArguments', 'isArray', 'isString');
          _.pull(objDepMap.shimKeys, 'support');

          source = replaceFunction(source, 'keys', [
            'var keys = !nativeKeys ? shimKeys : function(object) {',
            '  return isObject(object) ? nativeKeys(object) : [];',
            '};'
          ].join('\n'));

          source = replaceFunction(source, 'shimKeys', [
            'function shimKeys(object) {',
            '  var index = -1,',
            '      props = keysIn(object),',
            '      length = props.length,',
            '      result = [];',
            '',
            '  while (++index < length) {',
            '    var key = props[index];',
            '    if (hasOwnProperty.call(object, key)) {',
            '      result.push(key);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.keysIn`
        if (!isLodash('keysIn')) {
          _.pull(funcDepMap.keysIn, 'isArguments', 'isArray', 'isString');
          _.pull(objDepMap.keysIn, 'support');

          source = replaceFunction(source, 'keysIn', [
            'function keysIn(object) {',
            '  var result = [];',
            '  if (!isObject(object)) {',
            '    return result;',
            '  }',
            '  for (var key in object) {',
            '    result.push(key);',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.last`
        if (!isLodash('last')) {
          _.pull(funcDepMap.last, 'createCallback');

          source = replaceFunction(source, 'last', [
            'function last(array, n, guard) {',
            '  var length = array ? array.length : 0;',
            '  if (n == null || guard) {',
            '    return array ? array[length - 1] : undefined;',
            '  }',
            '  n = length - (n || 0);',
            '  return slice(array, n < 0 ? 0 : n);',
            '}'
            ].join('\n'));
        }
        // replace `_.matches`
        if (!isLodash('matches')) {
          _.pull(funcDepMap.matches, 'baseIsEqual', 'isObject');

          source = replaceFunction(source, 'matches', [
            'function matches(source) {',
            '  var props = keys(source),',
            '      propsLength = props.length;',
            '',
            '  return function(object) {',
            '    var length = propsLength;',
            '    if (length && !object) {',
            '      return false;',
            '    }',
            '    var result = true;',
            '    while (length--) {',
            '      var key = props[length];',
            '      if (!(result = hasOwnProperty.call(object, key) &&',
            '          object[key] === source[key])) {',
            '        break;',
            '      }',
            '    }',
            '    return result;',
            '  };',
            '}'
          ].join('\n'));
        }
        // replace `_.memoize`
        if (!isLodash('memoize')) {
           source = replaceFunction(source, 'memoize', [
              'function memoize(func, resolver) {',
              '  if (!isFunction(func) || (resolver && !isFunction(resolver))) {',
              '    throw new TypeError(funcErrorText);',
              '  }',
              '  var cache = {};',
              '  return function() {',
              "    var key = resolver ? resolver.apply(this, arguments) : arguments[0];",
              "    if (key == '__proto__') {",
              '      return func.apply(this, arguments);',
              '    }',
              '    return hasOwnProperty.call(cache, key)',
              '      ? cache[key]',
              '      : (cache[key] = func.apply(this, arguments));',
              '  };',
              '}'
          ].join('\n'));
        }
        // replace `_.omit`
        if (!isLodash('omit')) {
          _.pull(funcDepMap.omit, 'createCallback', 'negate');

          source = replaceFunction(source, 'omit', [
            'function omit(object) {',
            '  var omitProps = baseFlatten(arguments, true, false, 1),',
            '      length = omitProps.length;',
            '',
            '  while (length--) {',
            '    omitProps[length] = String(omitProps[length]);',
            '  }',
            '  return pick(object, baseDifference(keysIn(object), omitProps));',
            '}'
          ].join('\n'));
        }
        // replace `_.partial`
        if (!isLodash('partial')) {
          source = replaceFunction(source, 'partial', [
            'function partial(func) {',
            '  return createWrapper(func, PARTIAL_FLAG, null, null, slice(arguments, 1));',
            '}'
          ].join('\n'));
        }
        // replace `_.partialRight`
        if (!isLodash('partialRight')) {
          source = replaceFunction(source, 'partialRight', [
            'function partialRight(func) {',
            '  return createWrapper(func, PARTIAL_RIGHT_FLAG, null, null, null, slice(arguments, 1));',
            '}'
          ].join('\n'));
        }
        // replace `_.pick`
        if (!isLodash('pick')) {
          _.pull(funcDepMap.pick, 'baseForIn', 'createCallback', 'isObject');

          source = replaceFunction(source, 'pick', [
            'function pick(object) {',
            '  var index = -1,',
            '      props = baseFlatten(arguments, true, false, 1),',
            '      length = props.length,',
            '      result = {};',
            '',
            '  while (++index < length) {',
            '    var key = props[index];',
            '    if (key in object) {',
            '      result[key] = object[key];',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.random`
        if (!isLodash('random')) {
          _.pull(funcDepMap.random, 'baseRandom');

          source = replaceFunction(source, 'random', [
            'function random(min, max) {',
            '  if (min == null && max == null) {',
            '    max = 1;',
            '  }',
            '  min = +min || 0;',
            '  if (max == null) {',
            '    max = min;',
            '    min = 0;',
            '  } else {',
            '    max = +max || 0;',
            '  }',
            '  return min + floor(nativeRandom() * (max - min + 1));',
            '}'
          ].join('\n'));
        }
        // replace `_.rest`
        if (!isLodash('rest')) {
          _.pull(funcDepMap.rest, 'createCallback');

          source = replaceFunction(source, 'rest', [
            'function rest(array, n, guard) {',
            '  if (n == null || guard) {',
            '    n = 1;',
            '  } else {',
            '    n = n < 0 ? 0 : n;',
            '  }',
            '  return slice(array, n);',
            '}'
            ].join('\n'));
        }
        // replace `_.result`
        if (!isLodash('result')) {
          source = replaceFunction(source, 'result', [
            'function result(object, key) {',
            '  if (object != null) {',
            '    var value = object[key];',
            '    return isFunction(value) ? object[key]() : value;',
            '  }',
            '}'
          ].join('\n'));
        }
        // replace `_.sortBy`
        if (!isLodash('sortBy')) {
          _.pull(funcDepMap.sortBy, 'compareMultipleAscending', 'isArray');

          source = replaceFunction(source, 'sortBy', [
            'function sortBy(collection, callback, thisArg) {',
            '  var index = -1,',
            '      length = collection && collection.length,',
            '      result = Array(length < 0 ? 0 : length >>> 0);',
            '',
            '  callback = lodash.createCallback(callback, thisArg, 3);',
            '  baseEach(collection, function(value, key, collection) {',
            '    result[++index] = {',
            "      'criteria': callback(value, key, collection),",
            "      'index': index,",
            "      'value': value",
            '    };',
            '  });',
            '',
            '  length = result.length;',
            '  result.sort(compareAscending);',
            '  while (length--) {',
            '    result[length] = result[length].value;',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.tap`
        if (!isLodash('tap')) {
          source = replaceFunction(source, 'tap', [
            'function tap(value, interceptor) {',
            '  interceptor(value);',
            '  return value;',
            '}'
          ].join('\n'));
        }
        // replace `_.template`
        if (!isLodash('template')) {
          _.pull(funcDepMap.template, 'keys', 'values');
          _.pull(varDepMap.template, 'reInterpolate');

          source = replaceFunction(source, 'template', [
            'function template(string, data, options) {',
            '  var _ = lodash,',
            '      settings = _.templateSettings;',
            '',
            "  string = String(string == null ? '' : string);",
            '  options = defaults({}, options, settings);',
            '',
            '  var index = 0,',
            '      source = "__p += \'",',
            '      variable = options.variable;',
            '',
            '  var reDelimiters = RegExp(',
            "    (options.escape || reNoMatch).source + '|' +",
            "    (options.interpolate || reNoMatch).source + '|' +",
            "    (options.evaluate || reNoMatch).source + '|$'",
            "  , 'g');",
            '',
            '  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, evaluateValue, offset) {',
            '    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);',
            '    if (escapeValue) {',
            '      source += "\' +\\n_.escape(" + escapeValue + ") +\\n\'";',
            '    }',
            '    if (evaluateValue) {',
            '      source += "\';\\n" + evaluateValue + ";\\n__p += \'";',
            '    }',
            '    if (interpolateValue) {',
            '      source += "\' +\\n((__t = (" + interpolateValue + ")) == null ? \'\' : __t) +\\n\'";',
            '    }',
            '    index = offset + match.length;',
            '    return match;',
            '  });',
            '',
            '  source += "\';\\n";',
            '  if (!variable) {',
            "    source = 'with (obj || {}) {\\n' + source + '\\n}\\n';",
            '  }',
            "  source = 'function(' + (variable || 'obj') + ') {\\n' +",
            '    "var __t, __p = \'\', __j = Array.prototype.join;\\n" +',
            '    "function print() { __p += __j.call(arguments, \'\') }\\n" +',
            '    source +',
            "    'return __p\\n}';",
            '',
            '  try {',
            "    var result = Function('_', 'return ' + source)(_);",
            '  } catch(e) {',
            '    e.source = source;',
            '    throw e;',
            '  }',
            '  if (data) {',
            '    return result(data);',
            '  }',
            '  result.source = source;',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.throttle`
        if (!isLodash('throttle')) {
          source = replaceFunction(source, 'throttle', [
            'function throttle(func, wait, options) {',
            '  var leading = true,',
            '      trailing = true;',
            '',
            '  if (!isFunction(func)) {',
            '    throw new TypeError(funcErrorText);',
            '  }',
            '  if (options === false) {',
            '    leading = false;',
            '  } else if (isObject(options)) {',
            "    leading = 'leading' in options ? options.leading : leading;",
            "    trailing = 'trailing' in options ? options.trailing : trailing;",
            '  }',
            '  return debounce(func, wait, {',
            "    'leading': leading,",
            "    'maxWait': wait,",
            "    'trailing': trailing",
            '  });',
            '}'
          ].join('\n'));
        }
        // replace `_.toArray`
        if (!isLodash('toArray')) {
          _.pull(funcDepMap.toArray, 'isString').push('isArray', 'map');
          _.pull(objDepMap.toArray, 'support');

          source = replaceFunction(source, 'toArray', [
            'function toArray(collection) {',
            '  if (isArray(collection)) {',
            '    return slice(collection);',
            '  }',
            "  if (collection && typeof collection.length == 'number') {",
            '    return map(collection);',
            '  }',
            '  return values(collection);',
            '}'
          ].join('\n'));
        }
        // replace `baseUniq`
        if (!(isUnderscore && (isLodash('baseUniq') || isLodash('uniq')))) {
          _.pull(funcDepMap.baseUniq, 'cacheIndexOf', 'createCache');

          source = replaceFunction(source, 'baseUniq', [
            'function baseUniq(array, isSorted, callback) {',
            '  var length = array ? array.length : 0;',
            '  if (!length) {',
            '    return [];',
            '  }',
            '  var index = -1,',
            '      indexOf = getIndexOf(),',
            '      result = [],',
            '      seen = (callback && !isSorted) ? [] : result;',
            '',
            '  while (++index < length) {',
            '    var value = array[index],',
            '        computed = callback ? callback(value, index, array) : value;',
            '',
            '    if (isSorted) {',
            '      if (!index || seen !== computed) {',
            '        seen = computed;',
            '        result.push(value);',
            '      }',
            '    }',
            '    else if (indexOf(seen, computed) < 0) {',
            '      if (callback) {',
            '        seen.push(computed);',
            '      }',
            '      result.push(value);',
            '    }',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace `_.uniqueId`
        if (!isLodash('uniqueId')) {
          source = replaceFunction(source, 'uniqueId', [
            'function uniqueId(prefix) {',
            "  var id = ++idCounter + '';",
            '  return prefix ? prefix + id : id;',
            '}'
          ].join('\n'));
        }
        // replace `_.zip`
        if(!isLodash('zip')) {
          source = replaceFunction(source, 'zip', [
            'function zip() {',
            '  var index = -1,',
            "      length = max(pluck(arguments, 'length')),",
            '      result = Array(length < 0 ? 0 : length);',
            '',
            '  while (++index < length) {',
            '    result[index] = pluck(arguments, index);',
            '  }',
            '  return result;',
            '}'
          ].join('\n'));
        }
        // replace references to external `lodash.createCallback` with internal `createCallback`
        if (!isLodash('createCallback')) {
          source = source.replace(/\blodash\.(createCallback\()\b/g, '$1');
        }
        // replace decimal NCRs in `htmlEscapes` with hexadecimal NCRs
        if (!isLodash('escape')) {
          _.each(['htmlEscapes', 'htmlUnescapes', 'reEscapedHtml'], function(varName) {
            source = source.replace(matchVar(source, varName), function(match) {
              return match.replace('#39', '#x27');
            });
          });
        }
        // remove `_.prototype.toString`
        if (!isModularize && !isLodash('chain')) {
          _.pull(funcDepMap.wrapperValueOf, 'wrapperToString');
        }
        // remove `_.bindKey` support from `baseCreateWrapper` and `createWrapper`
        if (!isLodash('bindKey')) {
          source = source.replace(matchFunction(source, 'baseCreateWrapper'), function(match) {
            return match.replace(/^( *)if *\(isBindKey\b[\s\S]+?\n\1}\n/gm, '');
          });

          source = source.replace(matchFunction(source, 'createWrapper'), function(match) {
            return match
              .replace(/!isBindKey *&& */, '')
              .replace(/^( *)if *\(arity\b([\s\S]+?\n\1}){2}\n/m, '');
          });
        }
        // remove `_.curry` support from `baseCreateWrapper`
        if (!isLodash('curry')) {
          source = source.replace(matchFunction(source, 'baseCreateWrapper'), function(match) {
            return match.replace(/^( *)if *\(isCurry\b[\s\S]+?\n\1}\n/gm, '');
          });
        }
        // remove `_.partialRight` support from `baseCreateWrapper`
        if (!isLodash('partialRight')) {
          _.pull(funcDepMap.baseCreateWrapper, 'composeArgsRight');

          _.each(['baseCreateWrapper', 'createWrapper'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match
                .replace(/,\s*partialRightHolders\b(?: *=.+?(?=[,;]))?/g, '')
                .replace(/^( *)if *\((isPartialRight|partialRightArgs)\b[\s\S]+?\n\1}\n/gm, '');
            });
          });
        }
        // remove support for a `step` of `0` in `_.range`
        if (!isLodash('range')) {
          source = source.replace(matchFunction(source, 'range'), function(match) {
            return match.replace(/\bstep *== *null\b[^;]+/, '+step || 1');
          });
        }
        // remove metadata optimizations
        source = removeEsOptimization(source);
        _.pull(funcDepMap.createWrapper, 'slice');
        _.pull(funcDepMap.support, 'isNative');
        _.pull(objDepMap.baseCreateCallback, 'support');

        _.each(['baseBind', 'baseCreateCallback', 'baseCreateWrapper'], function(funcName) {
          _.pull(funcDepMap[funcName], 'setData');
        });

        // remove `baseBind` from `createWrapper`
        _.pull(funcDepMap.createWrapper, 'baseBind');

        source = source.replace(matchFunction(source, 'createWrapper'), function(match) {
          return match.replace(/^( *return )[^;]+?(?=baseCreateWrapper)/m, '$1');
        });

        // remove callback support from `_.isEqual`, `_.omit`, and `_.pick`
        _.each(['isEqual', 'omit', 'pick'], function(funcName) {
          if (!isLodash(funcName) && !(funcName == 'isEqual' && isLodash('baseIsEqual'))) {
            _.pull(funcDepMap[funcName], 'baseCreateCallback', 'createCallback');
          }
        });

        // remove conditional `charCodeCallback` use from `_.max` and `_.min`
        _.each(['max', 'min'], function(funcName) {
          if (!isLodash(funcName)) {
            _.pull(funcDepMap[funcName], 'charAtCallback', 'isArray', 'isString');

            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/=.+?isString[^:]+:\s*/g, '= ');
            });
          }
        });

        // unexpose "exit early" feature from functions
        if (!isLodash('forEach') && !isLodash('forEachRight') &&
            !isLodash('forIn') && !isLodash('forInRight') &&
            !isLodash('forOwn') && !isLodash('forOwnRight')) {

          source = source.replace(matchVar(source, 'expando'), function(match) {
            return match + [
              '',
              '  /** Used by methods to exit iteration */',
              "  var breakIndicator = expando + 'breaker__';",
              ''
            ].join('\n');
          });

          source = source.replace(matchFunction(source, 'some'), function(match) {
            return match.replace(/!\(result *= *(.+?)\);/, '(result = $1) && breakIndicator;');
          });

          source = source.replace(matchFunction(source, 'transform'), function(match) {
            return match.replace(/return callback[^)]+\)/, '$& === false && breakIndicator');
          });

          _.each(['arrayEach', 'arrayEachRight', 'baseEach', 'baseEachRight', 'baseFor', 'baseForRight'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/=== *false/g, '=== breakIndicator');
            });
          });

          _.each(['baseIsEqual', 'every'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/\(result *= *(.+?)\);/g, '!(result = $1) && breakIndicator;');
            });
          });

          _.each(['baseFind', 'shimIsPlainObject'], function(funcName) {
            source = source.replace(matchFunction(source, funcName), function(match) {
              return match.replace(/return false/, 'return breakIndicator');
            });
          });
        }
      }
      if (isModularize) {
        _.each(['baseDifference', 'baseUniq', 'contains', 'intersection'], function(funcName) {
          _.pull(funcDepMap[funcName], 'getIndexOf').push('baseIndexOf');
        });
      }
      // alias `baseCreateCallback` as `createCallback`
      if (_.contains(minusFuncs, 'pluck') && _.contains(minusFuncs, 'where')) {
        _.pull(funcDepMap.createCallback, 'matches', 'property');
        source = replaceFunction(source, 'createCallback', 'var createCallback = baseCreateCallback;');
      }
      // remove "_.pluck" or "_.where" style callback support from `_.createCallback`
      else {
        _.each(['pluck', 'where'], function(funcName) {
          if (_.contains(minusFuncs, funcName)) {
            _.pull(funcDepMap.createCallback, funcName);
            funcDepMap.createCallback.push('identity');

            source = source.replace(matchFunction(source, 'createCallback'), function(match) {
              var otherName = funcName == 'where' ? 'matches' : 'property';
              _.pull(funcDepMap.createCallback, otherName);
              return match.replace(RegExp('\\b' + otherName + '\\([^)]+\\)', 'm'), 'identity');
            });
          }
        });
      }
      // add function names explicitly
      if (!_.isEmpty(includeFuncs)) {
        result = includeFuncs;
      }
      // add default function names
      if (_.isEmpty(includeObjs) && _.isEmpty(includeVars)) {
        if (isBackbone && !result) {
          result = backboneDependencies;
        }
        else if (isUnderscore && !result) {
          result = underscoreFuncs;
        }
        if (!result) {
          result = lodashFuncs.slice();
        }
      }
      // remove special "none" entry
      if (result == 'none') {
        result = [];
      } else {
        _.pull(result, 'none');
      }
      // add and subtract function names
      if (!_.isEmpty(plusFuncs)) {
        result = _.union(result, plusFuncs);
      }
      if (!_.isEmpty(minusFuncs)) {
        result = _.difference(result, minusFuncs.concat(getDependants(minusFuncs, funcDepMap)));
      }
      if (isModularize) {
        _.pull(result, 'runInContext');
      }
      return getDependencies(result, funcDepMap);
    }());

    // expand properties, variables, and their function dependencies to include in the build
    (function() {
      function expand(includes, allDeps, depMap, funcNames, stack) {
        stack || (stack = []);
        _.each(funcNames || buildFuncs, function(funcName) {
          if (_.contains(stack, funcName)) {
            return;
          }
          stack.push(funcName);
          _.each([varDepMap, objDepMap], function(otherDepMap) {
            var depNames = otherDepMap[funcName];
            if (depNames) {
              var validDeps = _.transform(depNames, function(result, depName) {
                var depNames = depMap[depName];
                push.apply(result, depNames || []);
              });

              push.apply(validDeps, _.filter(depNames, _.partial(_.contains, allDeps, _, 0)));

              var otherNames = _.transform(validDeps, function(result, depName) {
                push.apply(result, getDependencies(funcDepMap[depName], funcDepMap));
              });

              push.apply(includes, validDeps);
              push.apply(buildFuncs, otherNames);
              expand(includes, allDeps, depMap, otherNames, stack);
            }
          });
        });
      }

      expand(includeObjs, objDependencies, objDepMap);
      expand(includeVars, varDependencies, varDepMap);

      buildFuncs = _.uniq(buildFuncs);
      includeObjs = _.union(includeObjs, _.intersection(objDependencies, includeVars));
      includeVars = _.union(includeVars, _.intersection(varDependencies, includeObjs));
    }());

    /*------------------------------------------------------------------------*/

    // load customized Lo-Dash module
    var lodash = !isTemplate && (function() {
      var context = vm.createContext({
        'clearTimeout': clearTimeout,
        'console': console,
        'setTimeout': setTimeout
      });

      vm.runInContext(source, context);
      return context._;
    }());

    /*------------------------------------------------------------------------*/

    if (isTemplate) {
      source = buildTemplate({
        'moduleId': moduleId,
        'source': source,
        'templatePattern': templatePattern,
        'templateSettings': templateSettings
      });
    }
    else {
      if (isUnderscore) {
        // unexpose Lo-Dash methods for the Underscore build
        source = source.replace(getMethodAssignments(source), function(match) {
          var unexpose = [
            'assign', 'create', 'callback', 'createCallback', 'escapeRegExp',
            'findIndex', 'isPlainObject', 'keysIn', 'negate', 'noop', 'slice',
            'unzip', 'zipObject'
          ];

          return _.reduce(unexpose, function(result, funcName) {
            if (isLodash(funcName)) {
              return result;
            }
            return result.replace(RegExp('^( *//.*\\n)* *lodash\\.' + funcName + ' *=[\\s\\S]+?;\\n(\\n)?', 'gm'), function(match, comment, newline) {
              return (!newline && comment) || newline || '';
            });
          }, match);
        });

        if (!isModularize) {
          // remove `_.templateSettings.imports assignment
          source = source.replace(/,[^']*'imports':[^}]+}/, '');

          // unexpose `lodash.support`
          if (!isLodash('support')) {
            source = source.replace(/\blodash\.support *= */, '');
          }
        }
      }
      if (isModularize) {
        source = removeGetIndexOf(source);

        // replace the `lodash.templateSettings` property assignment with a variable assignment
        source = source.replace(/\b(lodash\.)(?=templateSettings *=)/, 'var ');

        // remove the `lodash` namespace from properties
        source = source.replace(/\blodash\.(?!com|prototype)([$\w]+)\b(?!\s*=)/g, '$1');

        // remove all horizontal rule comment separators
        source = source.replace(/^ *\/\*-+\*\/\n/gm, '');

        // remove `lodash` branch in `_.mixin`
        source = source.replace(matchFunction(source, 'mixin'), function(match) {
          return match.replace(/^(?: *\/\/.*\n)*( *)if *\(!source\b[\s\S]+?\n\1}\n+/m, '');
        });

        // replace `lodash` use in `_.templateSettings.imports`
        source = source.replace(matchProp(source, 'templateSettings'), function(match) {
          return match.replace(/(:\s*)lodash\b/, "$1{ 'escape': escape }");
        });

        source = source.replace(matchFunction(source, 'template'), function(match) {
          if (isUnderscore) {
            // assign `_` using `template.imports`
            return match
              .replace(/(_ *= *)lodash\b/, '$1templateSettings.imports._')
              .replace(/= *_\.templateSettings(?=[,;])/, '$& || templateSettings');
          }
          return match
            // assign `settings` using `template.imports`
            .replace(/= *templateSettings(?=[,;])/, '$&.imports._.templateSettings || templateSettings')
            // remove debug sourceURL use in `_.template`
            .replace(/^(?: *\/\/.*\n)* *var sourceURL\b[^;]+;\n|\+ *sourceURL/gm, '');
        });

        // replace `root` with the appropriate global object for the specified `exports` option
        if (isAMD || isNode) {
          source = source.replace(/\bcontext(?=\.)/g, isAMD ? 'window' : 'global');
        }
        if (!isAMD) {
          source = removeVar(source, 'undefined');
        }
        source = removeRunInContext(source);
      }
    }

    /*------------------------------------------------------------------------*/

    // set the AMD module id
    if (isAMD && !isModularize && !isTemplate && moduleId && moduleId != 'none') {
      source = source.replace(/^ *define\((?=function)/m, "$&'" + moduleId + "', ");
    }
    // customize Lo-Dash's export bootstrap
    if (!isAMD || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if *\(typeof +define\b[\s\S]+?else /m, '$1');
    }
    if (!isNode || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*( *)if *\(moduleExports\b[\s\S]+?else *\{([\s\S]+?\n)\1}\n+/m, '$1$2');
    }
    if (!isCommonJS || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)}?) *else *\{)?\s*freeExports\.[$\w]+ *=[\s\S]+?(?:\n\2})?\n+/m, function(match, prelude) {
        return prelude ? prelude + '\n' : '';
      });
    }
    if (!isGlobal || isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)*(?:(( *)}?) *else(?: *if *\(_\))? *\{)?(?:\s*\/\/.*)*\s*(?:root\._|_\.templates) *=[\s\S]+?(?:\n\2})?\n+/gm, function(match, prelude) {
        return prelude ? prelude + '\n' : '';
      });
    }
    // remove `if (freeExports && freeModule) {...}` if it's empty
    if (isAMD && isGlobal && !isModularize) {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else )?if *\(freeExports.*?\) *\{\s*}\n+/m, '');
    } else {
      source = source.replace(/^(?: *\/\/.*\n)* *(?:else )?if *\(freeExports.*?\) *\{\s*}(?:\s*else *\{([\s\S]+?) *})?\n+/m, '$1\n');
    }

    /*------------------------------------------------------------------------*/

    // exit early to create modules
    if (isModularize) {
      buildModule({
        'buildFuncs': buildFuncs,
        'filePath': filePath,
        'funcDepMap': funcDepMap,
        'includeFuncs': includeFuncs,
        'includeObjs': includeObjs,
        'includeVars': includeVars,
        'isAMD': isAMD,
        'isCommonJS': isCommonJS,
        'isES6': isES6,
        'isModern': isModern,
        'isNode': isNode,
        'isNpm': isNpm,
        'isSilent': isSilent,
        'isStdOut': isStdOut,
        'isStrict': isStrict,
        'isUnderscore': isUnderscore,
        'lodash': lodash,
        'objDepMap': objDepMap,
        'options': options,
        'outputPath': outputPath,
        'source': source,
        'varDepMap': varDepMap
      }, callback);
      return;
    }
  }

  /*--------------------------------------------------------------------------*/

  // modify/remove references to removed functions/variables
  if (!isTemplate) {
    if (isExcluded(isModularize ? 'lodash' : 'lodashWrapper')) {
      // remove `lodashWrapper.prototype` assignment
      source = source.replace(/(?: *\/\/.*\n)* *lodashWrapper\.prototype *=.+\n/, '');
    }
    if (isExcluded(isModularize ? 'lodash' : 'mixin')) {
      source = removeMixinCalls(source);
    }
    if (isExcluded(isModularize ? 'lodash' : 'wrapperValueOf')) {
      source = removeChaining(source);
    }
    if (isModularize) {
      if (isExcluded('lodash')) {
        source = removeAssignments(source);
      }
    }
    else {
      if (isExcluded('clone', 'isElement', 'isEqual', 'isPlainObject')) {
        source = removeSupportNodeClass(source);
      }
      if (isExcluded('isArguments')) {
        source = replaceSupportProp(source, 'argsClass', 'true');
      }
      if (isExcluded('isArguments', 'isEmpty', 'isPlainObject')) {
        source = removeSupportArgsClass(source);
      }
      if (isExcluded('isElement')) {
        source = removeSupportDom(source);
      }
      if (isExcluded('isPlainObject')) {
        source = removeSupportOwnLast(source);
      }
      if (isExcluded('keysIn')) {
        source = removeSupportNonEnumShadows(source);
      }
      if (isExcluded('keysIn', 'shimKeys')) {
        source = removeSupportNonEnumArgs(source);
        source = removeSupportNonEnumStrings(source);
      }
      if (isExcluded('lodashWrapper')) {
        source = removeChaining(source);
      }
      if (!/\.(?:enumErrorProps|nonEnumShadows) *=/.test(source)) {
        // remove 'Error' from the `contextProps` array
        source = source.replace(/^ *var contextProps *=[\s\S]+?;/m, function(match) {
          return match
            .replace(/'Error',? */, '')
            .replace(/,(?=\s*])/, '');
        });
      }
    }
    // remove functions from the build
    _.each(allFuncs, function(funcName) {
      if (!_.contains(buildFuncs, funcName) &&
          !(funcName == 'lodash' && !isModularize)) {
        source = removeFunction(source, funcName);
        if (!isModularize) {
          source = removeMethodAssignment(source, funcName);
        }
      }
    });

    // remove forks of removed functions
    _.forOwn({
      'baseCreate': removeBaseCreateFork,
      'isArguments': removeIsArgumentsFork,
      'isArray': removeIsArrayFork,
      'isElement': removeIsElementFork,
      'isFunction': removeIsFunctionFork,
      'now': removeNowFork
    },
    function(removeFork, funcName) {
      if (isExcluded(funcName)) {
        source = removeFork(source);
      }
    });

    // remove unneeded property dependencies
    _.each(objDependencies, function(propName) {
      if (!_.contains(includeObjs, propName)) {
        source = removeProp(source, propName);
      }
    });

    // remove code used to resolve unneeded `support` properties
    source = source.replace(matchProp(source, 'support'), function(match) {
      return match.replace(/^ *\(function\(x\)[^{]+\{\n(( *)var ctor *=[\s\S]+?(?:\n *for.+)+\n)([\s\S]+?)}\(0, *0\)\);\n/m, function(match, setup, indent, body) {
        var modified = setup;

        if (!/\.spliceObjects *= *(?!false|true)/.test(body)) {
          modified = modified.replace(/^ *object *=.+\n/m, '');
        }
        if (!/\.enumPrototypes *= *(?!false|true)/.test(body) &&
            !/\.nonEnumShadows *= *(?!false|true)/.test(body) &&
            !/\.ownLast *= *(?!false|true)/.test(body)) {
          modified = modified
            .replace(/\bctor *=.+\s+/, '')
            .replace(/^ *ctor\.prototype.+\s+.+\n/m, '')
            .replace(/(?:,\n)? *props *=[^;=]+/, '')
        }
        if (!/\.nonEnumArgs *= *(?!false|true)/.test(body)) {
          modified = modified.replace(/\s*for *\(var argsKey\b[^}]+}/, '');
        }
        if (!/\.nonEnumStrings *= *(?!false|true)/.test(body)) {
          modified = modified.replace(/\s*for *\(var strKey\b[^}]+}/, '');
        }
        // cleanup the empty var statement
        modified = modified.replace(/^ *var;\n/m, '');

        // if no setup then remove IIFE
        return modified == false
          ? body.replace(RegExp('^' + indent, 'gm'), indent.slice(0, -2))
          : match.replace(setup, modified);
      });
    });

    // remove unneeded variable dependencies
    if (!_.contains(includeVars, 'root')) {
      source = removeVar(source, 'freeGlobal');
    }
    if (isModularize) {
      _.each(varDependencies, function(varName) {
        if (!_.contains(includeFuncs, varName) &&
            !_.contains(includeObjs, varName) &&
            !_.contains(includeVars, varName)) {
          source = removeVar(source, varName);
        }
      });
    }
    (function() {
      var isShallow = isExcluded('runInContext'),
          useMap = createMap(),
          snippet = cleanupSource(removeStrings(removeComments(source))),
          varNames = _.difference(getVars(snippet, isShallow), includeFuncs, includeObjs, includeVars);

      // remove unused variables
      while (varNames.length) {
        varNames = _.sortBy(varNames, function(varName) {
          var result = isVarUsed(snippet, varName, isShallow);
          useMap[varName] = result;
          return result;
        });

        if (useMap[varNames[0]]) {
          varNames.shift();
        }
        else {
          while (varNames.length && !useMap[varNames[0]]) {
            snippet = removeVar(snippet, varNames[0]);
            source = removeVar(source, varNames[0]);
            varNames.shift();
          }
        }
      }
    }());
  }

  // customize Lo-Dash's IIFE
  if (isIIFE) {
    source = replaceIIFE(source, iife);
  }

  /*--------------------------------------------------------------------------*/

  callback || (callback = defaultBuildCallback);
  debugSource = cleanupSource(source);
  source = debugSource;

  // flag to track if `outputPath` has been used by `callback`
  var outputUsed = false;

  // expand `outputPath` and create directories if needed
  if (outputPath) {
    outputPath = (function() {
      var dirname = path.dirname(outputPath);
      fs.mkdirpSync(dirname);
      return path.join(fs.realpathSync(dirname), path.basename(outputPath));
    }());
  }
  // used as the basename of the output path
  var basename = 'lodash';
  if (outputPath) {
    basename = outputPath;
  } else if (isTemplate) {
    basename += '.template' + (moduleId ? 's' : '');
  } else if (isCustom) {
    basename += '.custom';
  }
  // output debug build
  if (!isMinify && (isCustom || isDebug || isTemplate)) {
    if (isCustom) {
      debugSource = addCommandsToHeader(debugSource, options);
    }
    if (isDebug && isStdOut) {
      stdout.write(debugSource);
      callback({
        'source': debugSource
      });
    }
    else if (!isStdOut) {
      filePath = outputPath || path.join(cwd, basename + '.js');
      outputUsed = true;
      callback({
        'source': debugSource,
        'outputPath': filePath
      });
    }
  }
  // begin the minification process
  if (!isDebug) {
    if (outputPath && outputUsed) {
      outputPath = path.join(path.dirname(outputPath), path.basename(outputPath, '.js') + '.min.js');
    } else if (!outputPath) {
      outputPath = path.join(cwd, basename + '.min.js');
    }
    minify(source, {
      'filePath': filePath,
      'isMapped': isMapped,
      'isSilent': isSilent,
      'isTemplate': isTemplate,
      'modes': isIIFE ? ['simple', 'hybrid'] : ['simple', 'advanced', 'hybrid'],
      'outputPath': outputPath,
      'sourceMapURL': sourceMapURL,
      'onComplete': function(data) {
        if (isCustom) {
          data.source = addCommandsToHeader(data.source, options);
        }
        if (isStdOut) {
          delete data.outputPath;
          stdout.write(data.source);
        }
        callback(data);
      }
    });
  }
}

/*----------------------------------------------------------------------------*/

// export `build`
if (module != require.main) {
  module.exports = build;
}
// or invoked directly
else {
  build(process.argv);
}
